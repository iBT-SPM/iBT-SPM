function iBT_stats(iBT)
% Perform block- or event-related and/or functional connectivity
%  statistical analyses. 
% This script is designed to be called by iBT_analysis 
% FORMAT iBT_stats(iBT)
%  where 'iBT.what' is a structure indicating what is to be done,
%    and 'iBT.who' is a structure indicating subject specific details.
%___________________________________________________________________________
% Copyright 2004-2025 The Florey Institute of Neuroscience and Mental Health
%
% This file is part of iBT (the Integrated Brain Analysis Toolbox for SPM).
% See iBT_SPM.m for more information.

% iBT is free software: you can 
% redistribute it and/or modify it under the terms of the GNU General 
% Public License as published by the Free Software Foundation, either
% version 3 of the License, or (at your option) any later version.
% 
% iBT is distributed in the hope 
% that it will be useful, but WITHOUT ANY WARRANTY; without even the  
% implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
% PURPOSE.  See the GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program. If not, see <http://www.gnu.org/licenses/>.
%___________________________________________________________________________
%
% Recent Version History:
% 2025-12-30: Exit with error if SPM.mat already exists and 
%             iBT.what.stats.clobber is not set or zero.
%             In places where we save SPM.mat directly, incorporate same
%             logic as SPM12r7771 to dynamically determine MAT file format 
%             (i.e. use -v7.3 if the file will exceed 2GB).
% 2025-11-11: (dfa) Allow a path (folder) component in onset and duration
%   filespecs, so long as the path component does not contain a wildcard.
% 2024-10-27: (dfa)
%   Added 'Explicit' mask option to iBT.what.stats.r_withinBrainMask
%   and iBT.what.stats.n_withinBrainMask to then utilise new session-specific 
%   explicit mask wildcards iBT.who.sub{sub}.sess{ses}.wild.r_ExplicitMask
%   and iBT.who.sub{sub}.sess{ses}.wild.n_ExplicitMask respectively.
%   Bugfix: Testing iBT.what.stats.r_withinBrainMask for 'SPM' was instead
%           testing iBT.what.stats.n_withinBrainMask.
% 2024-07-30: (mfb) Replace iBT.what.stats.configureDesign with
%                   iBT.what.stats.design.configure, and add new
%                   iBT.what.stats.design.savePreliminaryFig
% 2024-07-12: (mfb) Can now output two sets of design matrix figures. First, with
%                   only the SPM orthogonalisation having been performed. Second, 
%                   after iBT orthogonalisation has been performed. Previously 
%                   the design matrix images were generated by SPM after it 
%                   performed orthogonalisation and so did not show the effect 
%                   of any orthogonalisation performed by iBT. This also fixes 
%                   instances where the welcome screen could remain overlaid 
%                   in the output (e.g. if running in command line mode).
% 2024-07-11: (dfa) Improve compatibility of indexing in orthogonalisation
%                   option 4 to remain compatible with future MATLAB releases.
% 2024-07-11: (mfb) New orthogonalisation option 4.1 
%                  (like 4, but skip block (constant) regressor) 
% 2024-06-25: (dfa)  Support   iBT.who.sub{sub}.sess{ses}.wild.r
%                      and     iBT.who.sub{sub}.sess{ses}.wild.n
%                      and     iBT.who.sub{sub}.sess{ses}.wild.denoised_r
%                      and     iBT.who.sub{sub}.sess{ses}.wild.denoised_n
%             If these are not set, then fall back to the legacy
%             global iBT.what.stats.[r_wild n_wild denoised.[r_wild n_wild]]
% 2024-02-07: (dfa) New orthogonalisation option 2.1 
%                  (like 2, but skip very last regressor) 
% 2022-08-05: (dfa) Fix crash that occured if attempted to use 
%                   confounds_fmriprep columns that begin with 'n/a'
%                   (such as occurs for derivative columns)
% 2022-05-17: (dfa) Fix broken iBT.what.stats.fc.put_first logic
% 2022-05-03: (dfa) Support iBT.what.stats.fc.put_first
% 2022-02-15: (dfa) Save design matrix in .png and MATLAB .fig formats 
%                    (in addition to .ps PostScript format)
% 2021-10-04: (dfa) Use iBT.who.sub{sub}.sess{ses}.wild.confounds_fmriprep
%                   instead of iBT.who.sub{sub}.sess{ses}.fmriprep.wild
%              NOTE: This change backwards incompatible with v3.9alpha03.
% 2021-07-26: (dfa) Fix occurrence & occurred spelling (affects log files)
% 2021-06-11: (dfa) Support iBT.what.stats.Confounds_fmriprep.do ,
%             iBT.who.sub{sub}.sess{ses}.Confounds_fmriprep ,
%         and iBT.who.sub{sub}.sess{ses}.fmriprep.wild ;
%         the latter, if present, is also now used with 
%         iBT.what.stats.mc.fmriprep
% 2021-02-02: (dfa) Support iBT.who.sub{sub}.sess{ses}.amp
%                    and iBT.who.sub{sub}.sess{ses}.amp_files
%  (dfa) To avoid confusion now that parametric modulation by event 
%        amplitude is supported, 
%        renamed old iBT.what.stats.parametric_modulation
%        to iBT.what.stats.parametric_modulation_by_separation
%  (dfa) Removed obsolete code that had permitted filenames in 
%        iBT.who.sub{sub}.sess{ses}.onsets,  whereas this variable was 
%        publicly documented to be only for directly specifying an array
%        of onset values;  filenames should be specified in 
%        iBT.who.sub{sub}.sess{ses}.onset_files
% 2020-11-30: (dfa) Replaced iBT.what.stats.onset_dur_type 
%			with more flexible iBT.what.stats.events.source
% 2020-05-23: (dfa) Support iBT.what.stats.mc.fd  (as a confound) and 
%                   iBT.what.stats.mc.metric = 'FramewiseDisplacement'
%                   (to use same for motion censoring, rather than 
%                     previous default 'DeltaOriginDistance')
% 2020-05-21: (dfa) Support iBT.what.stats.mc.fmriprep
% 2020-04-19: (dfa) Bugfix: Correct mask filename if not realigned to iBT target
% 2020-04-18: (dfa) More informative error message if don't find specified tscans 
% 2018-11-28: (dfa) Support iBT.what.stats.MAT64bit
% 2018-09-25: (dfa) Support iBT.what.stats.denoised.adjust_erdf
% 2018-09-19: (dfa) Support iBT.what.ext.SPM, iBT.what.ext.FSL and
%			iBT.what.ext.iB (image filename extensions)
% 2017-12-22: (dfa) Updated comment for SPM12 r6906 bug, now that r7219 is out.
% 2017-10-30: (dfa) Permit motion rejection even if motion regression is off.
% 2017-05-31: (dfa) Work around bug in SPM12 r6906 that causes a crash.
% 2016-06-29: (dfa) Log names of onset and duration files used, if applicable.
% 2016-05-30: (dfa) Don't throw an error if can't find realignment parameters
%		    when iBT.what.stats.mc.mp == 0.
% 2016-05-04: (dfa) Log Matlab Version
% 2015-11-11: (dfa) Improved cross-platform compatibility of 
%		    iBT.what.stats.data_link = 1.
% 2015-04-21: (dfa) New iBT.what.stats.denoised.SOCK.adjust_erdf flag
% 		    enables automatic reduction of degrees of freedom by
%		    the number of SOCK regressors used in denoising 
%		    (this addition was not merged with the mainline iBT
%		     code until 2015-11-11; prior to that it appeared
%		     only in a work-in-progress that was a mod of 3.5i,
%		     labelled 3.5j dated 2015.04.21 )
% 2014-10-31: (dfa) Replaced timecourse regressor textread calls with textscan
%		     as former can miss the last line if no end of line char.
% 2014-07-10: (dfa) Added support for an array of 2 scalars:
%		     iBT.who.sub{sub}.sess{ses}.denoised_pick_adjustment
%		     useful if one has denoised only a subset of the original
%		     preprocessed images. Set to [a b] where a = number of 
% 		     image volumes manually removed from start of session
%		     and b = number of volumes removed from end of session.
%                    If it exists, this is used to adjust the pick list
%		     when selecting denoised images (but not when extracting
%		     realignment parameters because the original realignment
%                    parameter file is used, for which the original pick is
%                    appropriate).
% 2014-07-03: (dfa) Support iBT.what.stats.denoised.do, .r_wild & .n_wild
% 2013-12-04: (dfa) Fix call to iBT_mrej when using a pre-estimated model.
% 2013-11-15: (dfa) Fixed crash when orth_regressors == 3.
%		    Fixed crash when orth_regressors == 1 in a multisession
%		    analysis.
% 2013-11-11: (dfa) Log median & maximum amount of scan to scan motion.
%		    Code cleanup and minor changes to support SPM12b.
% 2013-10-03: (dfa) New iBT.what.stats.extra_con
%                   Fixed contrast labels in multi-session analyses
% 2013-09-30: (dfa) Extend logging of motion rejection information to
%                   every regressor of interest (not just the first).
%		    Fixed a related crash that occurred when attempting
%		    to obtain rejection info for multisession designs.
% 2013-08-07: (dfa) Support iBT.what.stats.r_withinBrainMask and
%			iBT.what.stats.n_withinBrainMask.
%		    Ensure that when BET masking is selected, the wildcard
%		    determined is such that the binary  _mask file generated
%		    by BET is used even if a masked brain image also exists.
% 2013-02-20: (dfa) Support iBT.what.stats.mc.rejN (previously hard-coded=4).
% 2013-01-29: (dfa) Fixed crash due to typo if too few degrees of freedom.
% 2013-01-25: (dfa) Log more information regarding motion rejection.
%		Enable contrast generation when configureDesign already done.
% 2012-11-06: (dfa) Fixed bandpass filtering of second and
%                   subsequent sessions in FC multi-session analyses
%		   (thanks to Chris Tailby for finding this bug).
% 2012-04-04: (dfa) Display the number of scans rejected due to motion
%             (dfa) Generate contrasts for fc when what.stats.event_con=1
% 2012-03-12: (dfa) Display version info from iBT_version()
% 2012-02-16: (dfa) support iBT.who.sub{sub}.sess{ses}.ROI_loc
% 2012-02-12: (dfa) Added support for stats.fc.ROI_mask_timecourse.do
%		* Permit confound timecourses (no matter how specified)
%		  to be used in any sort of analysis (not just 
%		  functional connectivity); to facilitate this, 
%		  iBT.what.stats.fc.tc.do is now replaced by  
%		  stats.fc.timecourse.do and stats.Confounds_timecourse.do
%		* Added support for stats.configureDesign
%		  (default = 1) so that the design matrix can be configured
%		   and saved even if the model is not estimated.
%		* Bugfix: functional connectivity for multiple
%		  sessions was always using seed regions from first session.
%		* Bugfix: consistency check for number of scans only
%		  ever checked first session.
%		* Fixed adjustment of duration of the final event
%		  if event end is past the scan pick list (previously
%		  if this occurred the new duration for this event was 
%		  determined in units of scans rather than in the units
%		  specified in the runinfo).
%		* Log a warning and prevent crash if an event is
%		  specified prior to the first scan, and fixed correction
%		  applied to the event duration if the event overlaps
%		  with scanning onset. We ignore the prior event unless
%		  it overlaps with the first scan in which case the
%		  event is adjusted to commence at 0. Note that this is not 
%		  ideal because convolution with the HRF will delay the BOLD 
% 		  onset more than required for the real event start, however  
% 		  SPM does not presently provide a mechanism to specify task
%		  onsets that precede scanning.
%		* Removed some superfluous code, tidied things up a bit
%
% 2011-09-19: (dfa) Fixed a bug with contrast labels introduced in v3.0 
% 		    Fixed possible crash when sorting onset & duration files.
% 2011-08-26: (dfa) Updated for public release
%
% 2004-2011: iBT analysis scripts were developed by David Abbott based
%            upon the who & what structure concept of Tony Waites, with 
%            substantial contributions from Matt Harvey, Kaushik Bhaganagarapu,
%            and Richard Masterton.
%            In 2004, the script that ultimately became iBT_stats
%            began as an adaptation of a simpler script by Karl Friston.
%
% Todo - pass in the voxel sizes of own-space images if generating
%        a functional connectivity seed via a co-ordinate in an own-space analysis.


disp(sprintf('Entered stats script...'));

if isempty(iBT), error('Error: "iBT" structure is not defined.'), end

[iBTversion,iBTrelease,iBTversionReleaseString] = iBT_version(1); % Display version so it gets logged.
[iBT.what.SpmVersion, iBT.what.SpmRelease, iBT.what.SpmVersionReleaseString, MatlabVersion, MatlabDate, MatlabArch] = iBT_SPMversion(2);

%spm clear; % Reset the user interface, but unfortunately
% this doesn't reset the background and text colour, so do that now: 
%set(spm_figure('GetWin', 'Graphics'), 'Color', [1 1 1]);
%set(gcf,'DefaultTextColor','black');

format compact

% Maintain compatibility with old runinfo files that may not have 
% some new fields that are used in this function.
try, iBT.what.stats.evalCons; catch, iBT.what.stats.evalCons = 1; end % Default to 1 if not specified
try, iBT.what.stats.make_data_links_only; catch, iBT.what.stats.make_data_links_only = 0; end % Default to 0 if not specified
try, iBT.what.stats.fc.do; catch, iBT.what.stats.fc.do = 0; end
try, iBT.what.stats.Confounds_mask_timecourse.do; catch, iBT.what.stats.Confounds_mask_timecourse.do = 0; end
try, iBT.what.stats.fc.ROI_mask_timecourse.do; catch, iBT.what.stats.fc.ROI_mask_timecourse.do = 0; end
try, iBT.what.stats.check_onsets; catch, iBT.what.stats.check_onsets = 1; end
try, iBT.what.stats.design.configure; catch 
	try, iBT.what.stats.design.configure = iBT.what.stats.configureDesign; catch
		iBT.what.stats.design.configure = 1;
	end
end
try, iBT.what.stats.design.savePreliminaryFig; catch, iBT.what.stats.design.savePreliminaryFig = 0; end
try, iBT.what.error.stop; catch, iBT.what.error.stop = 1; end

try, fc_tmp = iBT.what.stats.fc.tc.do; catch, fc_tmp = 0; end
try, iBT.what.stats.fc.timecourse.do; catch, iBT.what.stats.fc.timecourse.do = fc_tmp; end
try, iBT.what.stats.Confounds_timecourse.do; catch, iBT.what.stats.Confounds_timecourse.do = fc_tmp; end
try, iBT.what.stats.Confounds_fmriprep.do; catch, iBT.what.stats.Confounds_fmriprep.do = 0; end
try, iBT.what.stats.mc.rejN; catch, iBT.what.stats.mc.rejN = 4; end
try, iBT.what.stats.mc.rejLog; catch, iBT.what.stats.mc.rejLog = 1; end % 1 = display number of task and rest scans affected by rejection regressors, 2 = display this even if no rejection.
try, iBT.what.ext.SPM; catch iBT.what.ext.SPM = '.img'; end % Used for images generated by SPM
try, iBT.what.ext.FSL; catch iBT.what.ext.FSL = '.img'; end % Used for images generated by MELODIC
try, iBT.what.ext.iB;  catch iBT.what.ext.iB  = '.img'; end % Used for images generated by iBrain
try, iBT.what.stats.denoised.do; catch, iBT.what.stats.denoised.do = 0; end
try, iBT.what.stats.denoised.folder; catch, iBT.what.stats.denoised.folder = fullfile('swa_all.ica','denoised_imgs'); end
try, iBT.what.stats.denoised.SOCK.adjust_erdf; catch, iBT.what.stats.denoised.SOCK.adjust_erdf = 0; end
try, iBT.what.stats.denoised.adjust_erdf; catch, iBT.what.stats.denoised.adjust_erdf = 0; end
try, iBT.what.stats.MAT64bit; catch iBT.what.stats.MAT64bit = 0; end
try, iBT.what.disp.fix_for_SPM12r6906_applied; catch iBT.what.disp.fix_for_SPM12r6906_applied = 0; end
try, iBT.what.stats.mc.fmriprep; catch iBT.what.stats.mc.fmriprep = 0; end 
try, iBT.what.stats.mc.metric; catch iBT.what.stats.mc.metric = 'DeltaOriginDistance'; end % Legacy. Now recommend 'FramewiseDisplacement'
try, iBT.what.stats.mc.fd; catch iBT.what.stats.mc.fd = 0; end % Include framewise displacement as a confound regressor (whether or not also used as a rejection criteria)
try, iBT.what.stats.mc.radius; catch iBT.what.stats.mc.radius = 50; end % Radius for which to determine equivalent displacement for rotations (50mm, as per Poewer et al 2012). 
try, iBT.what.stats.fc.put_first; catch iBT.what.stats.fc.put_first = 0; end % Default is to put connectivity regressors last in the design matrix. 
try, iBT.what.stats.clobber; catch iBT.what.stats.clobber = 0; end % Set non-zero if you do not mind if SPM.mat already exists 

% If only global wildcards were specified, set the equivalent subject/session specific variables:
for sub = 1:iBT.who.nsub	
  for ses = 1:iBT.who.sub{sub}.nses
  
	try, iBT.who.sub{sub}.sess{ses}.wild.r; catch 
		try, iBT.who.sub{sub}.sess{ses}.wild.r = iBT.what.stats.r_wild; catch
			iBT.who.sub{sub}.sess{ses}.wild.raw = ['sr*' iBT.what.ext.FSL]; %Default if unspecified (SPM smoothed, realigned)
		end % inner try wild.r
	end % outer try wild.r

	try, iBT.who.sub{sub}.sess{ses}.wild.n; catch 
		try, iBT.who.sub{sub}.sess{ses}.wild.n = iBT.what.stats.n_wild; catch
			iBT.who.sub{sub}.sess{ses}.wild.n = ['sw*' iBT.what.ext.FSL]; %Default if unspecified (SPM smoothed, normalised)
		end % inner try wild.n
	end % outer try wild.n

	try, iBT.who.sub{sub}.sess{ses}.wild.denoised_r; catch 
		try, iBT.who.sub{sub}.sess{ses}.wild.denoised_r = iBT.what.stats.denoised.r_wild; catch
			iBT.who.sub{sub}.sess{ses}.wild.denoised_r = ['dsr*' iBT.what.ext.FSL]; %Default if unspecified
		end % inner try wild.denoised_r
	end % outer try wild.denoised_r

	try, iBT.who.sub{sub}.sess{ses}.wild.denoised_n; catch 
		try, iBT.who.sub{sub}.sess{ses}.wild.denoised_n = iBT.what.stats.denoised.n_wild; catch
			iBT.who.sub{sub}.sess{ses}.wild.denoised_n = ['dsw*' iBT.what.ext.FSL]; %Default if unspecified
		end % inner try wild.denoised_n
	end % outer try wild.denoised_n

  end % for ses
end % for sub

try, iBT.what.stats.parametric_modulation_by_separation; catch,
	try iBT.what.stats.parametric_modulation_by_separation = iBT.what.stats.parametric_modulation; 
	% The previous non-specific variable name was deprecated to avoid confusion with parametric modulation by event amplitude
	catch iBT.what.stats.parametric_modulation_by_separation = 0;
end;end;

try, iBT.what.stats.events.source; catch, 
    try, iBT.what.stats.onset_dur_type,
      % iBT.what.stats.onset_dur_type flag is deprecated, replaced by the more human readable iBT.what.stats.events.source 
      switch(iBT.what.stats.onset_dur_type),
        case 0, iBT.what.stats.events.source = 'runinfo';
	case 1, iBT.what.stats.events.source = 'textfile';
	case 2, iBT.what.stats.events.source = 'runinfo & textfile';
	case 3, iBT.what.stats.events.source = 'none';
	otherwise, 
		% We  warn about deprecation if the value is unrecognised, as users might as well update if the old variable wrong.
		disp('ERROR: Unrecognised value for iBT.what.stats.onset_dur_type');
		disp('WARNING: iBT.what.stats.onset_dur_type is deprecated. Please use iBT.what.stats.events.source in new scripts');
		error('Unable to continue. Please update your runinfo file to address these issues.');
	end %switch
    catch,
		% If neither events.source nor the deprecated onset_dur_type is set, we'll assume there are no events:
		disp("WARNING: iBT.what.stats.events.source is undefined. Assuming 'none'.");
    		iBT.what.stats.events.source = 'none';
    end % try iBT.what.stats.onset_dur_type
end % try, iBT.what.stats.events.source

spm('defaults','fmri'); % Ensure we are starting with standard defaults
if iBT.what.stats.MAT64bit == 1
	spm_get_defaults('mat.format','-v7.3'); % Allows .mat files to include variables larger than 2GB on 64-bit computers
	disp('MATLAB MAT-file version set to -v7.3 to allow 64-bit MAT files on 64-bit computers');
end

% iBT.what.stats.r_ExplicitMask.wild is a wildcard for the mask file for every session.
% It used to be set in the runinfo file but the code was getting complicated with
% options for different mask types so we simplified the runinfo with use of the
% iBT.what.stats.r_ExplicitMask indicator, and moved the conditional code here.
% More recently, we introduced capability to specify session-specific mask wildcards,
% but we retain the global code below for backward compatibility (it is only engaged
% when iBT.what.stats.r_withinBrainMask is not set at all).
try, iBT.what.stats.r_withinBrainMask; 
catch,
	try, iBT.what.stats.r_ExplicitMask.wild;
		iBT.what.stats.r_withinBrainMask = iBT.what.stats.r_ExplicitMask.wild; % Set to this for information purposes only
	catch
		if iBT.what.pre.Create_r_BETwithinBrainMask ~= 0, iBT.what.stats.r_withinBrainMask = 'BET';
		elseif iBT.what.pre.Create_r_iBrainWithinBrainMask ~= 0, iBT.what.stats.r_withinBrainMask = 'iBrain';
		else iBT.what.stats.r_withinBrainMask = 'SPM';
		end
	end
end

try, iBT.what.stats.n_withinBrainMask; 
catch, 
	try, iBT.what.stats.n_ExplicitMask.wild;
		iBT.what.stats.n_withinBrainMask = iBT.what.stats.n_ExplicitMask.wild; % Set to this for information purposes only
	catch
		if iBT.what.pre.Create_n_BETwithinBrainMask ~= 0, iBT.what.stats.n_withinBrainMask = 'BET';
		elseif iBT.what.pre.Create_n_iBrainWithinBrainMask ~= 0, iBT.what.stats.n_withinBrainMask = 'iBrain';
		else iBT.what.stats.n_withinBrainMask = 'SPM';
		end
	end
end

if ~strcmpi(iBT.what.stats.r_withinBrainMask,'Explicit')

try, iBT.what.stats.r_ExplicitMask.wild; % test for legacy wildcard (was not session specific)
catch,
       	% Set appropriate mask to apply to realigned non-normalised images:
	r_withinBrainMask_postfix = '';
	if strcmpi(iBT.what.stats.r_withinBrainMask, 'SPM'), r_withinBrainMask_prefix = '';
	elseif strcmpi(iBT.what.stats.r_withinBrainMask, 'iBrain'), r_withinBrainMask_prefix = 'iBrainMask';
	elseif strcmpi(iBT.what.stats.r_withinBrainMask, 'BET'),
		r_withinBrainMask_prefix = 'BETmask';
		r_withinBrainMask_postfix = '_mask';
	else error(sprintf('Mask type %s unknown (should be either iBrain, BET or SPM, or set iBT.what.stats.r_ExplicitMask.wild)',iBT.what.stats.r_withinBrainMask));
	end
	
	if strcmpi(iBT.what.stats.r_withinBrainMask,'SPM' ),
		iBT.what.stats.r_ExplicitMask.wild ='' ;% '' = use default SPM determined mask
	else % use explicit mask file
		    if (iBT.what.pre.iBrainRealignTarget == 0) | (iBT.what.pre.Realign == 0),
       	   	    	iBT.what.stats.r_ExplicitMask.wild = [r_withinBrainMask_prefix '_mean' r_withinBrainMask_postfix iBT.what.ext.SPM]; 
		    else
			[ref_path ref_name ref_ext] = fileparts(iBT.what.pre.wild.ref);
			ref_sans_ext = fullfile(ref_path,ref_name);
       	   	    	iBT.what.stats.r_ExplicitMask.wild = [r_withinBrainMask_prefix '_mean' ref_sans_ext r_withinBrainMask_postfix ref_ext]; 
		    end % if (iBT.what.pre.iBrainRealignTarget... else...
	end % if strcmpi else
end %try, catch

end % if ~strcmpi(iBT.what.stats.r_withinBrainMask,'Explicit')

if ~strcmpi(iBT.what.stats.n_withinBrainMask,'Explicit')

try, iBT.what.stats.n_ExplicitMask.wild; % test for legacy wildcard (was not session specific)
catch, 
       	% Set appropriate mask to apply to spatially normalised images:
	n_withinBrainMask_postfix = ''; 
	if strcmpi(iBT.what.stats.n_withinBrainMask, 'SPM'), n_withinBrainMask_prefix = '';
	elseif strcmpi(iBT.what.stats.n_withinBrainMask, 'iBrain'), n_withinBrainMask_prefix = 'iBrainMask';
	elseif strcmpi(iBT.what.stats.n_withinBrainMask, 'BET'),
		n_withinBrainMask_prefix = 'BETmask';
		n_withinBrainMask_postfix = '_mask';
	else error(sprintf('Mask type %s unknown (should be either iBrain, BET or SPM, or set iBT.what.stats.n_ExplicitMask.wild)',iBT.what.stats.n_withinBrainMask));
	end
	
	if strcmpi(iBT.what.stats.n_withinBrainMask,'SPM' ),
		iBT.what.stats.n_ExplicitMask.wild ='' ;% '' = use default SPM determined mask
	else % use explicit mask files
       	  	if ( iBT.what.pre.norm.intra.do == 0 ) && ( iBT.what.pre.norm.BiasCorrect == 0 )		  
		    if (iBT.what.pre.iBrainRealignTarget == 0) | (iBT.what.pre.Realign == 0),
       	   	    	iBT.what.stats.n_ExplicitMask.wild = [n_withinBrainMask_prefix '_wmean' n_withinBrainMask_postfix iBT.what.ext.SPM]; 
		    else
			[ref_path ref_name ref_ext] = fileparts(iBT.what.pre.wild.ref);
			ref_sans_ext = fullfile(ref_path,ref_name);
       	   	    	iBT.what.stats.n_ExplicitMask.wild = [n_withinBrainMask_prefix '_wmean' ref_sans_ext n_withinBrainMask_postfix ref_ext]; 
		    end % if (iBT.what.pre.iBrainRealignTarget... else...
       	  	else
           	    iBT.what.stats.n_ExplicitMask.wild = [n_withinBrainMask_prefix '_wmean_all'          n_withinBrainMask_postfix ref_ext];
       	  	end
	end % if strcmpi else
end %try, catch

end % if ~strcmpi(iBT.what.stats.n_withinBrainMask,'Explicit')


% Specify design
%===========================================================================

SPM=iBT.what.stats.SPM;
  try
    SPM.xBF.UNITS = iBT.what.stats.onset_dur_units;
  end

start_cwd = cd;

cwd = iBT.what.stats.dir; 	% analysis working directory

if ~strcmp(iBT.what.SpmVersion, 'SPM2')
    cd(filesep()); % needed as matlab 6 behaves differently and creates dir in current directory regardless
end

[SUCCESS,MESSAGE,MESSAGEID] = mkdir(cwd) ; % Create it if it doesn't already exist
if ~SUCCESS
  disp(sprintf('Error: Unable to create subdirectory: %s',cwd))
  disp(sprintf('       (%s)',MESSAGE))
  return
end

disp(sprintf('Analysis directory: %s',cwd))
cd(cwd);

if iBT.what.stats.clobber == 0
  if exist('SPM.mat','file') ~= 0
     error(sprintf('Error: SPM.mat file already exists and iBT.what.stats.clobber is not enabled.'))
  end
end

first_ses = iBT.what.first_ses;  % start with this session (counting from 1) (set in iBT_start.m)
last_ses = iBT.what.last_ses;  % end with this session (set in iBT_start.m)
nsess = 1 + last_ses - first_ses;  % number of sessions to analyse in this instance of iBT_stats

% This script can do single or multi-session designs. 
% Multi-subject single-session design is also possible by
% configuring the input iBT to look like a single-subject
% multi-session design (iBT_start uses this trick).
sub = iBT.what.do_sub; % set in iBT_start.m
% Subject specific variables
%===========================================================================
for ses=first_ses:last_ses

  session = 1 + ses - first_ses; % Allows us to analyze a specified range (even just one) in this loop
  
  pick{session} = iBT.who.sub{sub}.sess{ses}.pick; 			% range of volumes to include in analysis
  try
  	denoised_pick_adjustment{session} = iBT.who.sub{sub}.sess{ses}.denoised_pick_adjustment; % Number of images removed from start and end of session after realignment was performed.
  catch
  	denoised_pick_adjustment{session} = [0 0];
  end
  if size(denoised_pick_adjustment{session},2) ~=2
  	error(sprintf('Error: denoised_pick_adjustment must be an array of exactly 2 elements: number of image volumes removed from start and end.'))
  end
  
  nvolumes(session) = length(iBT.who.sub{sub}.sess{ses}.pick);	% number of volumes to include in the analysis
  if nvolumes(session) == 0
  	error(sprintf('Error: Specified pick must contain a number range'))
  end

  if iBT.who.sub{sub}.sess{ses}.nscans > 0 && iBT.who.sub{sub}.sess{ses}.nscans ~= nvolumes(session)
  	error(sprintf('Error: Specified nscans of %d does not match pick range', iBT.who.sub{sub}.sess{ses}.nscans))
  else
	iBT.who.sub{sub}.sess{ses}.nscans = nvolumes(session);
  end

  dat_dir{session} = iBT.who.sub{sub}.sess{ses}.loc;		% pre-processed data location for this subject
  params{session}.ID = iBT.who.sub{sub}.ID;

  if strfind(iBT.what.stats.events.source,'runinfo') > 0,  % Obtain onsets etc. from variables set in runinfo
      clear tempnumOns
      try	
        temp=iBT.who.sub{sub}.sess{ses}.onsets{1}; % This will fail if not a cell
        params{session}.onset = iBT.who.sub{sub}.sess{ses}.onsets;
      catch
        params{session}.onset = {iBT.who.sub{sub}.sess{ses}.onsets};
      end %try
	
      try
        temp=iBT.who.sub{sub}.sess{ses}.dur{1}; % This will fail if not a cell
        params{session}.dur = iBT.who.sub{sub}.sess{ses}.dur;
      catch
        params{session}.dur = {iBT.who.sub{sub}.sess{ses}.dur};
      end %try

      if isfield(iBT.who.sub{sub}.sess{ses},'amp'),  % There are also event amplitudes
       try	
        temp=iBT.who.sub{sub}.sess{ses}.amp{1}; % This will fail if not a cell
        params{session}.amp = iBT.who.sub{sub}.sess{ses}.amp;
       catch
        params{session}.amp = {iBT.who.sub{sub}.sess{ses}.amp};
       end %try
      end;  % if isfield(iBT.who.sub{sub}.sess{ses},'amp') 

      try	
        temp=iBT.who.sub{sub}.sess{ses}.task{1}; % This will fail if not a cell
        params{session}.name = iBT.who.sub{sub}.sess{ses}.task;
      catch
        params{session}.name = {iBT.who.sub{sub}.sess{ses}.task};
      end %try
  end;  % if strfind(iBT.what.stats.events.source,'runinfo') > 0

  if strfind(iBT.what.stats.events.source,'textfile') > 0,  % Obtain onsets from specified file(s) 
      clear ons_name dur_name temp_onset temp_dur
      
      fnOns = iBT_get(iBT.what.where.awd, iBT.who.sub{sub}.sess{ses}.onset_files);
      fnDur = iBT_get(iBT.what.where.awd, iBT.who.sub{sub}.sess{ses}.dur_files);
	    if isfield(iBT.who.sub{sub}.sess{ses},'amp_files'),  % There may also be event amplitudes in files 
              fnAmp = iBT_get(iBT.what.where.awd, iBT.who.sub{sub}.sess{ses}.amp_files);
	    else
	      fnAmp = [''];
	    end % if isfield(iBT.who.sub{sub}.sess{ses},'amp_files') else
	
      numOns = size(fnOns,1);
      if numOns < 1
        display('')
        display(sprintf('Unable to find any onset files matching %s',iBT.who.sub{sub}.sess{ses}.onset_files))
        error(sprintf('Please check that the onset files exist.'))
      else
        for f=1:numOns
          display(sprintf('Found onset file %s',fnOns(f,:)))
          [junk, fname] = fileparts(fnOns(f,:));
          ons_name{f} = fname(1:end-4); % Removes the '_ons' from the filename
          temp_onset{f} = load( strcat(fnOns(f,:),'')   ); 
          % The strcat here is to remove trailing space characters created when spm_get returns all 
          % strings of same length (of the longest name found)
          display(sprintf('Found duration file %s',fnDur(f,:)))
           [junk, fname] = fileparts(fnDur(f,:));
          dur_name{f} = fname(1:end-4); % Removes the '_dur' from the filename
          temp_dur{f} = load( strcat(fnDur(f,:),'') );
	  if ( size(fnAmp,1) >= f ), % Because some onset files might not have corresponding amp files
           display(sprintf('Found amplitude file %s',fnAmp(f,:)))
            [junk, fname] = fileparts(fnAmp(f,:));
           amp_name{f} = fname(1:end-4); % Removes the '_amp' from the filename
           temp_amp{f} = load( strcat(fnAmp(f,:),'') );
	  end % if ( size(fnAmp,1) >= f )
        end %for f
	
        %  Make sure the filenames are sorted alphabetically
        [ons_name, ix] = sort(ons_name);
        temp_onset = temp_onset(ix);
	% The durations may not be read in same order as onsets, so sort separately:
        [dur_name, ix2] = sort(dur_name);
        temp_dur = temp_dur(ix2);
	if sum(~strcmp(ons_name, dur_name)) % If any names don't match, this sum will be non-zero
		error('Error: Sorted onset and duration labels do not match');
 	end
	numAmp = size(fnAmp,1);
	if ( numAmp > 0 ), 
		% The amplitudes may not be read in same order as onsets, so sort separately:
		[amp_name, ix3] = sort(amp_name);
		temp_amp = temp_amp(ix3);
		% Since amplitudes are optional, we can't rely on a bulk strcmp like we did above. So we loop over each onset and set missing amplitudes to []
		AmpNo=1;
		for f=1:numOns
	 		if strcmp(ons_name(f), amp_name(AmpNo)),
				% A match
				temp2_amp{f} = temp_amp{AmpNo};
				AmpNo = AmpNo + 1; 
			else
				% Not a match, so assume no amplitudes for these onsets
				temp2_amp{f} = [];
			end
		end %for f
		disp(sprintf('%0i of %0i onset files have matching amplitude files.', AmpNo-1, numOns ));
		if AmpNo > numAmp
			% Good - all amplitudes have been allocated.
			temp_amp = temp2_amp;
	 	else
 	 		% There are left over amplitudes! We'll leave temp_amp and temp2_amp as-is to help debugging
	 		disp(sprintf('Error: %0i amplitude file(s) found that do not apear to match an onset file:', numAmp-(AmpNo-1) ));
			error('Error: Sorted onset and amplitude labels do not match.');			
		end % if AmpNo > numAmp
	end %if ( size(fnAmp,1) > 0 )
	
        % Set the final variables for this subject
	if isfield(params{session},'onset'), % then append to existing onsets:
           params{session}.name = [params{session}.name ons_name];
           params{session}.onset = [params{session}.onset temp_onset];
           params{session}.dur = [params{session}.dur temp_dur];
           if ( size(fnAmp,1) > 0 ), params{session}.amp = [params{session}.amp temp_amp]; end
	else % these are the only onsets:
           params{session}.name = ons_name;
           params{session}.onset = temp_onset;
           params{session}.dur = temp_dur;
           if ( size(fnAmp,1) > 0 ), params{session}.amp = temp_amp; end
	end % if isfield(params{session},'onset')

      end % if numOns < 1 else
  end; % if strfind(iBT.what.stats.events.source,'textfile') > 0

  if strcmpi(iBT.what.stats.events.source,'none'), % i.e. No onsets at all (e.g. pure functional connectivity)
       params{session}.name = iBT.who.sub{sub}.sess{session}.task;
  end

  % Read TR from saved info file:
  [present, value] = iBT_info(iBT.who.sub{sub}.sess{ses}.infoFile,'TR(s)',1);
  if present, 
    	settings.ses{session}.TR = value; 
  else 
    	error(['Unable to find "TR(s):" in: ' iBT.who.sub{sub}.sess{ses}.infoFile]);
  end
  disp(sprintf(' TR is %f seconds.',settings.ses{session}.TR));

  if strcmp(iBT.what.stats.onset_dur_units, 'secs')
      convert_to_scans = settings.ses{session}.TR; % Divide by this to convert units to scans; multiply to convert back to units.
  else
      convert_to_scans = 1;
  end

  if isfield(params{session}, 'onset'), % we have some onsets
    
    for c = 1:1:length(params{session}.onset)
	params{session}.onset{c} = params{session}.onset{c} + iBT.what.stats.offset; % Add specified time offset to the specified onset
	  
	if (iBT.what.stats.check_onsets ~=0 )
	  
          % find last index in given pick
          last_index = find(iBT.who.sub{sub}.sess{ses}.pick);
          last_index = length(last_index); % i.e. This is the number of scans that we are going to analyse.

	  for i = length(params{session}.onset{c}):-1:1
		original_onset = params{session}.onset{c}(i)/convert_to_scans;
		original_dur = params{session}.dur{c}(i)/convert_to_scans;

	        % check if onset is fully outside upper pick range
        	if original_onset >= last_index
			disp('Warning (event truncation): An event that occurred after the last included scan has been removed.');
			disp(sprintf('        (removed onset = %f, duration = %f)', params{session}.onset{c}(i) ,params{session}.dur{c}(i)));
                	params{session}.onset{c} = params{session}.onset{c}(1:(i - 1));
	                params{session}.dur{c} = params{session}.dur{c}(1:(i - 1));
	                if ( isfield(params{session},'amp') ) && ( size(params{session}.amp{c},1) > 0 ), 
				params{session}.amp{c} = params{session}.amp{c}(1:(i - 1)); 
			end	
        	% check if offset onset is partially outside upper pick range
	        elseif (original_onset + original_dur) > last_index, % Changed from >= to > on 2021-02-02 as was alerting when OK even though nothing needed to be altered when the event exacly ended at the end of the last scan (= beginning of next scan).
			% change the final event duration so that it finishes by the end 
			% of the last scan, and make sure it is in the same units as 
			% originally specified.
			disp('Warning (event truncation): The portion of an event that extended after the last included scan has been removed.');
			disp(sprintf('        (previously onset = %f, duration = %f)', params{session}.onset{c}(i) ,params{session}.dur{c}(i)));
        	        params{session}.dur{c}(i) = (last_index - original_onset) * convert_to_scans;
			disp(sprintf('        (       now onset = %f, duration = %f)', params{session}.onset{c}(i) ,params{session}.dur{c}(i)));
	        else
        	        break;
	        end
	  end %for i
				
	  for i = length(params{session}.onset{c}):-1:1 % Count down from end to make it easier to remove invalid events as we go.
        	original_onset = params{session}.onset{c}(i)/convert_to_scans;
	        original_dur = params{session}.dur{c}(i)/convert_to_scans;;

	        % check if onset is fully outside lower pick range
        	if (original_onset + original_dur) < 0
			disp('Warning (event truncation): An event that occurred prior to the first included scan has been removed.');
			disp(sprintf('        (removed onset = %f, duration = %f)', params{session}.onset{c}(i) ,params{session}.dur{c}(i)));
	                params{session}.onset{c} = params{session}.onset{c}((i + 1):length(params{session}.onset{c}));
        	        params{session}.dur{c} = params{session}.dur{c}((i + 1):length(params{session}.dur{c}));
        	        if ( isfield(params{session},'amp') ) && ( size(params{session}.amp{c},1) > 0 ), 
				params{session}.amp{c} = params{session}.amp{c}((i + 1):length(params{session}.amp{c})); 
			end
	        % check if offset onset is partially outside lower pick range
        	elseif (original_onset < 0) && (original_onset + original_dur >= 0)
			disp('Warning (event truncation): The portion of an event that commenced prior to the first included scan has been removed.');
			disp(sprintf('        (previously onset = %f, duration = %f)', params{session}.onset{c}(i) ,params{session}.dur{c}(i)));
        	        params{session}.onset{c}(i) = 0 ; % since a prior event is not supported
        	        params{session}.dur{c}(i) = ( original_dur + original_onset) * convert_to_scans; % Original_onset is negative here.
			disp(sprintf('        (       now onset = %f, duration = %f)', params{session}.onset{c}(i) ,params{session}.dur{c}(i)));
        	else
                	break;
	        end
	  end %for i
	  
	end % if (iBT.what.stats.check_onsets ~=0 )
	 
    end % for c
    
  end; % if isfield(params{session}, 'onset')


  % Note: iBT.what.stats.norm is set in iBT_start.m, based on other settings in runinfo
  if iBT.what.stats.norm == 0  

    % Smooth used for realigned non-normalised images
    settings.ses{session}.smooth = iBT.what.pre.r_smooth_fwhm; 
    if strcmpi(iBT.what.stats.r_withinBrainMask,'Explicit') % Then use the specified session-specific wildcard:
      ExplicitMask_wild = iBT.who.sub{sub}.sess{ses}.wild.r_ExplicitMask;
    else
      ExplicitMask_wild = iBT.what.stats.r_ExplicitMask.wild;
    end
    if iBT.what.stats.denoised.do, 
    	a_wild.sub{sub}.sess{ses} = iBT.who.sub{sub}.sess{ses}.wild.denoised_r; 
    else
    	a_wild.sub{sub}.sess{ses} = iBT.who.sub{sub}.sess{ses}.wild.r; % wildcard for analysis images
    end
    if (iBT.what.stats.fc.voxel.do == 1 ),
      error('Sorry, this code is not complete - we need to obtain voxel size of images being analysed for own-space analysis.');
      voxel_size = [1 1 1]; % Size of the voxels we are analysing; [x y z] in mm.
    end
  else
    settings.ses{session}.smooth = iBT.what.pre.n_smooth_fwhm; % Smooth used for normalised images
    if strcmpi(iBT.what.stats.n_withinBrainMask,'Explicit') % Then use the specified session-specific wildcard:
      ExplicitMask_wild = iBT.who.sub{sub}.sess{ses}.wild.n_ExplicitMask;
    else
      ExplicitMask_wild = iBT.what.stats.n_ExplicitMask.wild;
    end
   if iBT.what.stats.denoised.do, 
    	a_wild.sub{sub}.sess{ses} = iBT.who.sub{sub}.sess{ses}.wild.denoised_n; 
    else
    	a_wild.sub{sub}.sess{ses} = iBT.who.sub{sub}.sess{ses}.wild.n; % wildcard for analysis images
    end
    voxel_size = iBT.what.pre.norm.write.vox; % Size of the voxels we are analysing; [x y z] in mm.
  end % if iBT.what.stats.norm == 0 else

  if (ses > first_ses)
      if settings.ses{session}.TR ~= settings.ses{1}.TR  
        error(sprintf('Error: TR of session %d (%f) is different from TR of session %d (%f).', ...
         ses,settings.ses{session}.TR,first_ses,settings.ses{1}.TR))
      end
  else
      if ~isempty(ExplicitMask_wild)

        if (nsess > 1) && (iBT.what.pre.norm.do ~= 0) && (iBT.what.pre.norm.intra.do ~= 0) 
            % bring in all the masks, find their intersection, save this,
            % and make this the new Explicit Mask
	    disp('Creating multi-session mask from masks in individual sessions...');
	    num_mask_ims = 0; % Initialise
	    for ses_maskloop=first_ses:last_ses
                if iBT.what.stats.norm == 0
                    if strcmpi(iBT.what.stats.r_withinBrainMask,'Explicit') % Then use the specified session-specific wildcards:
                      ExplicitMask_wild = iBT.who.sub{sub}.sess{ses_maskloop}.wild.r_ExplicitMask;
                    end
                else
                    if strcmpi(iBT.what.stats.n_withinBrainMask,'Explicit') % Then use the specified session-specific wildcards:
                      ExplicitMask_wild = iBT.who.sub{sub}.sess{ses_maskloop}.wild.n_ExplicitMask;
                    end
                end % if iBT.what.stats.norm == 0 else  
                switch (iBT.what.SpmVersion),
                    case 'SPM2',
                        nses_mask_fname = spm_get('Files',iBT.who.sub{sub}.sess{ses_maskloop}.loc, ...
                            ExplicitMask_wild);
                    otherwise
                        nses_mask_fname = spm_select('FPList',iBT.who.sub{sub}.sess{ses_maskloop}.loc, ...
                            spm_wildconvert(ExplicitMask_wild));
                end
		if length(nses_mask_fname) > 0
                	nses_mask_V = spm_vol(nses_mask_fname);
                	nses_mask_V_im = spm_read_vols(nses_mask_V);
               		nses_mask_V_im(nses_mask_V_im > 0) = 1;
                	if ses_maskloop == 1
               		     mask_im = nses_mask_V_im;
			     first_mask_filename = nses_mask_V.fname;
                	else
                	    mask_im = mask_im .* nses_mask_V_im;
                	end
			num_mask_ims = num_mask_ims + 1;
	    		disp(['  mask found for session ' num2str(ses_maskloop) ': ']);	
			disp(['   ' nses_mask_V.fname]);
		else
	    		disp(['  no explicit mask found for session ' num2str(ses_maskloop)]);	
		end
            end %for ses_maskloop
	    if num_mask_ims > 1
              % now write this mask image to file, assume the transformation
              % matrices are the same, having gotten this far
              combine_mask = nses_mask_V; % cheat and pre-fill image information from the last mask file
              combine_mask.fname = fullfile(pwd, filesep, ['multisessionMask' iBT.what.ext.SPM]);
              combine_mask.descrip = 'mask image defined as intersection of individual masks from each session';
              % and save the volume in the analysis directory of the first
              % session.
              combine_mask = spm_write_vol(combine_mask, mask_im);
	      Explicit_mask_fname = combine_mask.fname;
	      disp(['  written combined mask as: ']);
	      disp(['    ' Explicit_mask_fname]);
	    elseif num_mask_ims == 1
	      % Don't need to write a combined mask becasue there is only one. We assume OK to use this for all sessions.
	      Explicit_mask_fname = nses_mask_V.fname;
	      disp(['  only one mask found so will use it for all sessions: ']);
	      disp(['    ' nses_mask_V.fname]);
	    else % Must not be any masks, which is a critical error given that an ExplicitMask_wild was set. Stop and alert user.
		error_text = ['No explicit mask found in any session matching: ' ExplicitMask_wild]; % Consider expanding this to list all session-specific mask wildcards if present.
	      	if iBT.what.error.stop > 0
	      	  throw(MException('iBT_stats:mask',error_text ));
		else
		  disp(['Warning(iBT_stats): ' error_text]);
		end
	    end % if num_mask_ims > 0
	elseif (iBT.what.pre.sessions_together == 1) && ( (iBT.what.pre.norm.do == 0) || (iBT.what.pre.norm.intra.do == 0) )
	    % In this scenario there will only be a normalised mean image in the master session, so use that for all.
	    	Explicit_mask_dir = iBT.who.sub{sub}.sess{iBT.who.sub{sub}.MasterSession}.loc;
	else
		Explicit_mask_dir = dat_dir{session};
        end %if nsess > 1

  	if ~exist('Explicit_mask_fname','var')
        	switch (iBT.what.SpmVersion),
          	case 'SPM2',
            		Explicit_mask_fname = spm_get('Files',Explicit_mask_dir, ExplicitMask_wild)
          	otherwise
            		Explicit_mask_fname = spm_select('FPList',Explicit_mask_dir, ...
             		spm_wildconvert(ExplicitMask_wild))
        	end
		if isempty(Explicit_mask_fname)
			% No mask, which is a critical error given that an ExplicitMask_wild was set. Stop and alert user
			disp(['Searched for explicit mask in directory: ' Explicit_mask_dir])
			error_text = ['No explicit mask found matching: ' ExplicitMask_wild];
	      		if iBT.what.error.stop > 0
			  throw(MException('iBT_stats:mask', error_text));
			else
		  	  disp(['Warning(iBT_stats): ' error_text]);
			end
		end
	end % if ~exist('Explicit
      end %if ~isempty(ExplicitMask_wild)
  end %if (ses > first_ses)

  % For convenience, create a link called dataNNN to the processed data directory
  % for each session so easy to find 
  if (iBT.what.stats.data_link > 0)
  	data_link_name = sprintf('data%03d',session);
  	if exist(data_link_name,'file') == 0
	  if ispc,
	  	data_link_fullname = fullfile(pwd, [data_link_name '.lnk']);
		disp(['Creating Windows shortcut ' data_link_fullname ' pointing to ' dat_dir{session} ]);
	  	WShell = actxserver('WScript.Shell');
		WShell.Visible = false; 
		WShellLink = WShell.CreateShortcut(data_link_fullname); % The location and name of the link
		WShellLink.TargetPath = dat_dir{session}; % Where the link will point
         	WShellLink.Description = 'Shortcut to preprocessed data';		
	        WShellLink.Save;
		WShell.Quit;
		delete(WShell);
		clear WShell		
  		if exist(data_link_name,'file') == 0,
			disp(['Warning: failed to create Windows shortcut.']);
		else
			disp('Done.');
		end
	  else
		disp(['ln -s "' dat_dir{session} '" ' data_link_name ]);
		unix(['ln -s "' dat_dir{session} '" ' data_link_name ]);
	  end; %if ispc,
	end
  end; % if (iBT.what.stats.data_link > 0)

end %for ses

if  ( iBT.what.stats.make_data_links_only == 0 ), % Otherwise skip everything below

% Analysis specific variables
%===========================================================================

extra_motion_regressors = iBT.what.stats.mc.extra;  % specify whether to include 2nd order 
                              % polynomial expansion of motion regressors
                              % 0 = don't include
                              % 1 = include

motion_rejection = iBT.what.stats.mc.rej; % specify whether to automatically reject
                              % motion affected volumes.
                              % 0 = don't reject
                              % n = reject motions greater than "n" mm 
                              % (NOTE: n = 1 works well...)

bf_convolution = iBT.what.stats.SPM.xBF.Volterra;             % order of volterra kernels

parametric_modulation_by_separation = iBT.what.stats.parametric_modulation_by_separation;      % Specify the order - eg
                                % 0 = no modulation
                                % 1 = 1st order (linear)
                                % 2 = 2nd order (quadratic)

try
  orth_regressors = iBT.what.stats.orth_regressors; % Orthogonalises regressors for effects of interest
catch
  if (iBT.what.stats.fc.do == 0) % If not defined, assume don't want it unless doing fc.
    orth_regressors = 0; 
  else
    orth_regressors = 2; % Yes, all regressors in original order so last regressors orthogonalised last.
  end
end


% Begin analysis
%===========================================================================

cd(cwd);


% Number of scans and session
%===========================================================================
SPM.nscan          = nvolumes; % nvolumes is an array


% Trial specification: Onsets, duration (UNITS) and parameters for modulation
%---------------------------------------------------------------------------

neffects = 0; %initialise
parametric_count = 0; %initialise

for session=1:nsess

   if strcmpi(iBT.what.stats.events.source,'none'),
      SPM.Sess(session).U = {}; % No "effects" specified (usually for functional connectivity)
   else
    neffect{session} = length(params{session}.onset);
    neffects = neffects + neffect{session};
    for c=1:neffect{session}

      SPM.Sess(session).U(c).name      = {params{session}.name{c}};
      SPM.Sess(session).U(c).ons       = params{session}.onset{c};
      SPM.Sess(session).U(c).dur       = params{session}.dur{c};

      SPM.Sess(session).U(c).P(1).name = 'none'; % This may be overridden below
      SPM.Sess(session).U(c).P(1).h    = 0; % This may be overridden below
      
      if (isfield(params{session},'amp')) && ( size(params{session}.amp{c},1) > 0 ), % There are also event amplitudes, so include parametrically modulated regressors
        SPM.Sess(session).U(c).P(1).name = ['amp_' params{session}.name{c}] ;
        SPM.Sess(session).U(c).P(1).P    = params{session}.amp{c} ; 
        SPM.Sess(session).U(c).P(1).h    = 1; % Linear modulation. Should probably expose this in iBT structure
	parametric_count = parametric_count + 1;
      end; %if isfield(params{session},'amp') && etc.

      if parametric_modulation_by_separation

        %
        %  Parametric modulation by the distance between this spike and the previous one
        %
        %  this is done using a log scale which seems to linearise the
        %  distribution of the different offsets nicely.
        %
        parametric_count = parametric_count + 1;    
        SPM.Sess(session).U(c).P(parametric_count).name = 'separation';
        SPM.Sess(session).U(c).P(parametric_count).P    = SPM.Sess(session).U(c).ons(2:end) ...
         - SPM.Sess(session).U(c).ons(1:(end-1));
        SPM.Sess(session).U(c).P(parametric_count).P    = [SPM.Sess(session).U(c).ons(1) ; SPM.Sess(session).U(c).P(1).P];
        SPM.Sess(session).U(c).P(parametric_count).P    = log(SPM.Sess(session).U(c).P(1).P);
        SPM.Sess(session).U(c).P(parametric_count).h    = parametric_modulation_by_separation;
      end; %if parametric_modulation_by_separation

    end; % for c=1...
   end; % if strcmpi(iBT.what.stats.events.source,'none') else

   
end % for session


% Design (user specified covariates)
%===========================================================================
for ses=first_ses:last_ses
    	session = 1 + ses - first_ses; % Use session for SPM variables, ses for iBT variables.

	% Specify data: matrix of filenames
	if iBT.what.stats.denoised.do,
		session_dat_dir = fullfile(dat_dir{session},iBT.what.stats.denoised.folder); % Only the denoised images are here. Motion correction parameters etc remain in the original folder.
	else
		session_dat_dir = dat_dir{session};
	end %if iBT.what.stats.denoised.do
		
  	if (iBT.what.stats.denoised.SOCK.adjust_erdf == 1 )
		clear SOCK_info
  		SOCK_info = load(fullfile(session_dat_dir,'split_denoised_images'));
		SOCK.len_artifacts(session) = SOCK_info.len_artifacts; % Keep track of number of artefact regressors that were used in denoising preprocessing
		disp(sprintf('Retrieved regressor count used during previous denoising with SOCK: %i',SOCK.len_artifacts(session)));
  	end; % if (iBT.what.stats.denoised.SOCK.adjust_erdf == 1 )
	
        switch (iBT.what.SpmVersion),
          case 'SPM2',
            tmp = spm_get('Files',session_dat_dir,a_wild.sub{sub}.sess{ses});
          otherwise
            tmp = spm_select('FPList',session_dat_dir,spm_wildconvert(a_wild.sub{sub}.sess{ses}));
       	end
	
	tvolumes{session} = size(tmp,1);

	if iBT.who.sub{sub}.sess{ses}.tscans > 0 && iBT.who.sub{sub}.sess{ses}.tscans ~= tvolumes{session}
		error(sprintf('Error: Specified tscans of %d does not equal number of volumes (%0i) matching %s in directory %s', iBT.who.sub{sub}.sess{ses}.tscans, tvolumes{session}, a_wild.sub{sub}.sess{ses}, session_dat_dir))
	end
	
	% If analysing denoised images, normally all the original images will be denoised so the original pick list 
	% remains valid. However in some cases it may be advantageous to extract a subset of the original images
	% prior to denoising to avoid unneccessary processing (e.g. if the paradigm to be analysed is only a subset
	% of the original images, noting that unfortunately iBT at the present time does not apply
	% the pick list prior to pre-processing). If the image culling was done prior to iBT preprocessing it
	% won't be a problem (as long as the user sets the pick list according to the culled images). If however the
	% culling was done after pre-processg but prior to denoising the pick list still needs to be set according
	% to the non-culled images as that will be required to extract the correct realignment parameters from rp*.txt,
	% but an adjustment will be required when selecting the actual denoised images to analyse as they comprise
	% a subset of the original preprocessed images. This is accounted for by denoised_pick_adjustment{session}.	
	try
		if iBT.what.stats.denoised.do,
          		tmp = tmp((pick{session} - denoised_pick_adjustment{session}(1)),:);
		else
          		tmp = tmp(pick{session},:);
		end
	catch
		error(sprintf('Error: Insufficient number of volumes matching %s found in data directory %s', a_wild.sub{sub}.sess{ses}, session_dat_dir))
	end

        dir{session} = tmp;

	% Specify motion correction parameters
	if iBT.what.stats.mc.fmriprep == 1, 
		try, 
			mc_wild=iBT.who.sub{sub}.sess{ses}.wild.confounds_fmriprep; 
		catch, 
			try, 
				mc_wild=iBT.who.sub{sub}.sess{ses}.fmriprep.wild; % We introduced this only in v3.9alpha03 and replaced with above in v3.9alpha06
				iBT.who.sub{sub}.sess{ses}.wild.confounds_fmriprep = mc_wild; % Preserve compatibility with v3.9alpha03 (at least for use case when mc.fmriprep == 1)
			catch, 
				mc_wild = iBT.what.stats.mc.wild; 
			end
		end
	else
		mc_wild = iBT.what.stats.mc.wild; 	% wildcard for mc parameters
	end
        switch (iBT.what.SpmVersion),
          case 'SPM2',
	    mc_filename = spm_get('Files',dat_dir{session},mc_wild);
          otherwise
            mc_filename = spm_select('FPList',dat_dir{session},spm_wildconvert(mc_wild));
        end

	if isempty(mc_filename)
		if ( (iBT.what.stats.mc.mp ~= 0) || (iBT.what.stats.mc.rej ~= 0) )
			disp(['Searched for realignment parameters in directory: ' dat_dir{session}])
			disp([' (these parameters are expected because flag iBT.what.stats.mc.mp '])
			disp(['   and/or iBT.what.stats.mc.rej are/is non-zero)'])
			throw(MException('iBT_stats:realign_parameters', ['Unable to find file matching ' mc_wild]));
		end
	else
		if ((iBT.what.stats.mc.mp == 0) && (iBT.what.stats.mc.rej == 0))
			disp(['WARNING: Found file matching realignment parameter wildcard in directory: ' dat_dir{session}])
			disp([' (ignoring because flag iBT.what.stats.mc.mp and iBT.what.stats.mc.rej are both set to zero)'])
		else
			if ( size(mc_filename,1) > 1 )
				disp(['Found more than one file matching realignment parameter wildcard in directory: ' dat_dir{session}])
				disp(['Please remove or rename invalid files, or make the wildcard more specific. ' ])
				throw(MException('iBT_stats:realign_parameters', ['More than one file matching ' mc_wild]));
			else
				disp(['Reading realignment parameters from: ' mc_filename])
				if iBT.what.stats.mc.fmriprep == 1,
					fmriprepTSV=tdfread(mc_filename);
					r1=fmriprepTSV.trans_x;
					r2=fmriprepTSV.trans_y;
					r3=fmriprepTSV.trans_z;
					r4=fmriprepTSV.rot_x;
					r5=fmriprepTSV.rot_y;
					r6=fmriprepTSV.rot_z;
				else
	    				[r1,r2,r3,r4,r5,r6] = textread(mc_filename,'%f%f%f%f%f%f');
				end; %if iBT.what.stats.mc.fmriprep == 1, else
			end
		end
	end

    if ( (iBT.what.stats.mc.mp ~= 0) || (iBT.what.stats.mc.rej ~= 0) )
	% There are several possible rp_ files generated by iBT, as follows:
	% Single session rp_ file (with an additional 1st line if 
	%   an iBrain determined realignment target used)
	% Multi-session rp_ file containing parameters for that particular session
	%  (with an additional 1st line ONLY in the master session if an iBrain 
	%   determined realignment target used)
	% However it is possible to perform statistical analsyis separate from 
	% preprocessing, so we examine the number of entries in the rp file and
	% compare this to the number of images present in the folder (not just
	% those in the pick list) to determine whether the first line should be removed.
	%
	% Exception hack: If you have manually removed images (for example, if you have taken an 
	% existing pre-processing stream, removed some images and then run SOCK) the regular test
	% here will not work. We deal with this scenraio via 
	% iBT.who.sub{sub}.sess{ses}.denoised_pick_adjustment which is an array of two scalars [a b]
	% specifying the number of images removed from (a) the start and (b) the end of the session.
	% 
	
	  if ( size(r1,1) > (tvolumes{session} + denoised_pick_adjustment{session}(1) + denoised_pick_adjustment{session}(2)) )
		disp(sprintf('Discarding first line read from realignment parameter file in session %d',ses));
		disp(' (assumed to represent an iBrain-determined realignment target)');
		if(size(r1,1) > 1 + tvolumes{session})
			disp('Warning: Number of lines exceeds number expected (even after removing first line)');
		end
		
		r1 = r1([2:end]);
		r2 = r2([2:end]);
		r3 = r3([2:end]);
		r4 = r4([2:end]);
		r5 = r5([2:end]);
		r6 = r6([2:end]);
	  else
		disp(sprintf('Number of lines in realignment parameter file equals image count for session %d.',ses));
	  end

          r1 = r1(pick{session},:);
          r2 = r2(pick{session},:);
          r3 = r3(pick{session},:);
          r4 = r4(pick{session},:);
          r5 = r5(pick{session},:);
          r6 = r6(pick{session},:);
    end % if ( (iBT.what.stats.mc.mp ~= 0) || (iBT.what.stats.mc.rej ~= 0) )
    
    if iBT.what.stats.mc.mp ~= 0
      %
      %  Add standard motion parameters to design matrix
      %
     disp('Including six standard motion parameters as confound regressors');

      SPM.Sess(session).C.C    = [r1 r2 r3 r4 r5 r6];		% [n x c double] covariates
      SPM.Sess(session).C.name = {'X','Y','Z','x','y','z'};

      if (extra_motion_regressors)

        %
        %  Add non-linear and delayed motion parameters
        %
	disp('Including eighteen non-linear and delayed motion parameters as confound regressors');

        regressor_names = {'X^2','Y^2','Z^2','x^2','y^2','z^2', ... 
                           'X-1','Y-1','Z-1','x-1','y-1','z-1', ...
                           'X-1^2','Y-1^2','Z-1^2','x-1^2','y-1^2','z-1^2'};
        for n=1:size(regressor_names,2)
          SPM.Sess(session).C.name{end+1} = regressor_names{n};
        end

        SPM.Sess(session).C.C = [ SPM.Sess(session).C.C ...
                                  r1.^2 r2.^2 r3.^2 r4.^2 r5.^2 r6.^2 ...
                                  [0 r1(1:end-1)']' [0 r2(1:end-1)']' [0 r3(1:end-1)']' ...
                                  [0 r4(1:end-1)']' [0 r5(1:end-1)']' [0 r6(1:end-1)']' ...
                                  [0 r1(1:end-1)']'.^2 [0 r2(1:end-1)']'.^2 [0 r3(1:end-1)']'.^2 ...
                                  [0 r4(1:end-1)']'.^2 [0 r5(1:end-1)']'.^2 [0 r6(1:end-1)']'.^2];
      end %if (extra_motion_regressors)
    else % explicitly state no regressors
      SPM.Sess(session).C.C = [];
      SPM.Sess(session).C.name = {};
    end %if (iBT.what.stats.mc.mp)
 
  if ( (motion_rejection > 0.0) & strcmpi(iBT.what.stats.mc.metric,'FramewiseDisplacement') ) | ( iBT.what.stats.mc.fd ~= 0 )
    %
    %  Compute the framewise displacement metric as described in:
    %    Power et al. (2012) doi:10.1016/j.neuroimage.2011.10.018 
    %  and clarified (to detrend first, and first value zero) in:
    %    Power et al. (2014) doi:10.1016/j.neuroimage.2013.08.048
    %  They caution: "The purpose of this measure is to index head movement, not to precisely calculate or model it."
    
    disp('Determine framewise displacement...');
    % convert rotations in radians into motion in mm by projecting on to sphere (default radius is 50mm)
    rotations2displacement=iBT.what.stats.mc.radius * [r4 r5 r6];
    dtr=detrend([r1 r2 r3 rotations2displacement]); 
    ddtr=diff(dtr); 
    fwd = [ double(0) ; sum(abs(ddtr),2) ]; % Framewise displacement, with zero as first element by convention.

    if iBT.what.stats.mc.fd % Include Framewise displacement as a regressor
    	    disp('Including framewise displacement as a confound regressor');
    	    SPM.Sess(session).C.C = [ SPM.Sess(session).C.C fwd ];
    	    SPM.Sess(session).C.name{end+1} = 'FWD';
    end
    
  end % if ( (motion_rejection > 0.0) & strcmpi(iBT.what.stats.mc.metric,'FramewiseDisplacement') ) | ( iBT.what.stats.mc.fd ~= 0 )

  if (motion_rejection > 0.0) 
    %
    %  Create motion rejection regressors for movements of over  "motion_rejection" mm between scans
    %
    %  We then reject the next iBT.what.stats.mc.rejN number of scans
    %
    if strcmpi(iBT.what.stats.mc.metric,'FramewiseDisplacement'),
	motion{session} = fwd; % see above
    elseif strcmpi(iBT.what.stats.mc.metric,'DeltaOriginDistance'),
	disp('Determine scan to scan changes in distance from origin...');
    	motion{session} = sqrt(r1.*r1 + r2.*r2 + r3.*r3);
    	motion{session}(2:end) = abs(motion{session}(2:end) - motion{session}(1:end-1));
    	motion{session}(1) = 0;
    else
    	error(['Unknown iBT.what.stats.mc.metric ', iBT.what.stats.mc.metric]);
    end; %if iBT.what.stats.mc.metric 
    % Log maximum amount of scan to scan motion found, and median:
    disp(sprintf('Maximum scan to scan motion in this run = %g mm, median = %g mm', max(motion{session}), median(motion{session}) ));
    
    %
    %  Threshold (> motion_rejection mm)
    %
    motion{session}(find(motion{session} < motion_rejection)) = 0;
    motion{session}(find(motion{session})) = 1;
    rejected = find(motion{session});
    motion_events = length(rejected);
    rejectBlockSize = iBT.what.stats.mc.rejN;
    for r=1:length(rejected)
      block = rejected(r):rejected(r)+(rejectBlockSize-1);
      block = block(find(block <= length(motion{session})));
      motion{session}(block) = 1;
    end
    
    %
    %  Format into regressors
    %
    rejected = find(motion{session});
    reject = zeros(length(motion{session}),length(rejected)); 
    disp(sprintf('Occurrences of scan to scan motion exceeding %g mm: %4i; scan-nulling regressors: %4i;  scans remaining: %4i ', motion_rejection, motion_events, length(rejected), length(r1)-length(rejected) ) )
    if length(rejected) > 0
   	disp(sprintf(' (we reject each occurrence and the following %i scans to avoid T1 effects).', rejectBlockSize -1 ) )
   	disp(sprintf(' (here we have rejected %.1f0%% of the original %i scans).',length(rejected)*100/length(r1), length(r1)) )
    end
      for r=1:length(rejected)
        reject(rejected(r),r) = 1;
        SPM.Sess(session).C.name{end+1} = 'Reject';
      end
      if (iBT.what.stats.mc.mp) 
        SPM.Sess(session).C.C = [SPM.Sess(session).C.C reject];
      else
        SPM.Sess(session).C.C = [reject];
      end
  end % if (motion_rejection)
end % for ses

SPM.xY.P  = strvcat(dir{:});
SPM.xY.RT = settings.ses{1}.TR;	% seconds; Note: All scans assumed to have same TR


% Low frequency confound: high-pass cutoff (secs) [Inf = no filtering]
%=========================================================================== 
for session=1:nsess
    SPM.xX.K(session).HParam    = iBT.what.stats.SPM.xX.K.HParam;
end %for session


% Stuff designed for functional connectivity
%============================================

for ses=first_ses:last_ses
  session = 1 + ses - first_ses; % Use session for SPM variables, ses for iBT variables.

  seedname = {};  %Initialise
  nConfounds = 0; %Initialise
  nseedsOfInterest = 0; %Initialise

  try
  	ROI_loc = iBT.who.sub{sub}.sess{ses}.ROI_loc;
  catch 
 	ROI_loc = iBT.what.where.awd;
  end


  if iBT.what.stats.Confounds_timecourse.do ~= 0 
    %-----------------------------------------------------------------------
    %  Get pre-calculated confound time-courses from individual files.
    %  Such confounds can be very useful in functional connectivity 
    %  analyses but can also be used in other analyses if desired.
    %-----------------------------------------------------------------------
	
        if strcmp(iBT.what.SpmVersion, 'SPM2')
            VOI = spm_get('files',ROI_loc,iBT.who.sub{sub}.sess{ses}.Confounds_files);
        else
            VOI = spm_select('fplist',ROI_loc,spm_wildconvert(iBT.who.sub{sub}.sess{ses}.Confounds_files));
        end; %strcmp(iBT.what.SpmVersion, 'SPM2')
	nConfoundTC = size(VOI,1); % Number of counfounds specified via pre-calculated timecourses

        for s = 1:nConfoundTC
    
            if (iBT.what.stats.Confounds_timecourse.do == 1 ),
            	% Using iBrain extracted time-course
            	%Y = textread(deblank(VOI(s,:)));
		fidY = fopen(deblank(VOI(s,:)));
		Y = textscan(fidY,'%f');
		Y=Y{1};
		fclose(fidY);
            else
            	% Using SPM extracted VOI time-course
            	load(deblank(VOI(s,:)));
	    end
	  
            if (numel(Y) > nvolumes(session))
                Y = Y(pick{session});
		disp('Confound regressor lengths exceeded selected data length, so pick range has now been applied to the regressors');
	    end
	    if (numel(Y) < nvolumes(session))
	        error('Error: Confound regressor length is shorter than data length');
            end
    
            SPM.Sess(session).C.C = [SPM.Sess(session).C.C ((Y-mean(Y(:)))./std(Y(:)))];
            [dirname, fname] = fileparts(deblank(VOI(s,:)));
            SPM.Sess(session).C.name = {SPM.Sess(session).C.name{:} fname};
    
            disp(['Confound(' num2str(nConfounds + s) ') = ' fname]);
        end
 	nConfounds = nConfounds + nConfoundTC;
	
  end; % if iBT.what.stats.Confounds_timecourse.do

  if iBT.what.stats.Confounds_fmriprep.do ~= 0 

    %-----------------------------------------------------------------------
    %  Get pre-calculated confound time-courses from fmriprep. 
    %  Such confounds can be very useful in functional connectivity 
    %  analyses but can also be used in other analyses if desired.
    %-----------------------------------------------------------------------
	
        switch (iBT.what.SpmVersion),
          case 'SPM2',
	    fmriprep_filename = spm_get('Files',dat_dir{session},iBT.who.sub{sub}.sess{ses}.wild.confounds_fmriprep);
          otherwise
            fmriprep_filename = spm_select('FPList',dat_dir{session},spm_wildconvert(iBT.who.sub{sub}.sess{ses}.wild.confounds_fmriprep));
        end
	
	nConfoundsfMRIPrep = length(iBT.who.sub{sub}.sess{ses}.Confounds_fmriprep)  ; % Number of counfounds we want to extract from the fmriprep file

	if isempty(fmriprep_filename)
			disp(['Searched for fmriprep confounds file in directory: ' dat_dir{session}])
			disp([' (these parameters are expected because flag iBT.what.stats.Confounds_fmriprep.do '])
			disp(['   is non-zero)'])
			throw(MException('iBT_stats:confounds', ['Unable to find file matching ' iBT.who.sub{sub}.sess{ses}.wild.confounds_fmriprep]));
	else
			if ( size(fmriprep_filename,1) > 1 )
				disp(['Found more than one file matching realignment parameter wildcard in directory: ' dat_dir{session}])
				disp(['Please remove or rename invalid files, or make the wildcard more specific. ' ])
				throw(MException('iBT_stats:confounds', ['More than one file matching ' iBT.who.sub{sub}.sess{ses}.wild.confounds_fmriprep]));
			else
				disp(['Reading confounds from: ' fmriprep_filename])
					fmriprepTSV=tdfread(fmriprep_filename);
					
        			for s = 1:nConfoundsfMRIPrep
					tag = iBT.who.sub{sub}.sess{ses}.Confounds_fmriprep{s};
					if strcmp(class(fmriprepTSV.(tag)),'char'), % This can happen if data in column starts with not a number such as 'n/a' - see tdfread() help. 
						% Convert to double - things like 'n/a' then become NaN which is fine.
						Y=str2double(string(fmriprepTSV.(tag)));
					else
						Y=fmriprepTSV.(tag);
					end; %
					
			            if (numel(Y) > nvolumes(session))
			                Y = Y(pick{session});
					disp('fmriprep confound regressor length exceededs selected data length, so pick range has now been applied to the regressor');
				    end
        			    if (numel(Y) < nvolumes(session))
				        error('Error: fmriprep confound regressor length is shorter than data length');
			            end
			    
        		            SPM.Sess(session).C.C = [SPM.Sess(session).C.C ((Y-mean(Y(:)))./std(Y(:)))];
			            SPM.Sess(session).C.name = {SPM.Sess(session).C.name{:} tag};
			    
			            disp(['Confound(' num2str(nConfounds + s) ') = ' tag]);

        			end %for
 				nConfounds = nConfounds + nConfoundsfMRIPrep;
										
			end % if ( size(fmriprep_filename,1) > 1 )
    end % isempty(fmriprep_filename)

  end; % if iBT.what.stats.Confounds_fmriprep.do


  if iBT.what.stats.Confounds_mask_timecourse.do
    %-----------------------------------------------------------------------
    %  Get timecourses of confound masks - most useful for 
    %  use as confounds in functional connectivity analyses
    %  but can also be used in other analyses if desired.
    %-----------------------------------------------------------------------

    if strcmp(iBT.what.SpmVersion, 'SPM2')
        VOI = spm_get('files',ROI_loc,iBT.who.sub{sub}.sess{ses}.Confounds_mask);
    else
        VOI = spm_select('FPlist',ROI_loc,spm_wildconvert(iBT.who.sub{sub}.sess{ses}.Confounds_mask));
    end
    nConfoundROI = size(VOI,1); % Number of counfounds specified via masks

    VY = spm_vol(SPM.xY.P);
    for i=1:nConfoundROI
        VM = spm_vol(VOI(i,:));

        [X Y Z] = meshgrid(1:VY(1).dim(1),1:VY(1).dim(2),1:VY(1).dim(3));

        %  Transform into voxel coordinates in mask image
        vox = [X(:) Y(:) Z(:) ones(numel(X),1)]';
        vox = VY(1).mat*vox;
        vox = inv(VM.mat)*vox;

        %  Sample from the mask image
        mask = spm_sample_vol(VM, vox(1,:), vox(2,:), vox(3,:), 0);

        %  Choose the coordinates in the target image where the mask
        %  is greater than zero.
        X = X(find(mask > 0));
        Y = Y(find(mask > 0));
        Z = Z(find(mask > 0));

        R = zeros(length(VY),1);
        for t = 1:length(VY)
            R(t) = mean(spm_sample_vol(VY(t),X(:),Y(:),Z(:),0));
        end
        SPM.Sess(session).C.C = [SPM.Sess(session).C.C ((R-mean(R(:)))./std(R(:)))];
        SPM.Sess(session).C.name = {SPM.Sess(session).C.name{:} VM.fname};
        disp(['Confound(' num2str(nConfounds + i) ') = ' VM.fname]);	
    end % for
    nConfounds = nConfounds + nConfoundROI;
    clear VY;
  end; % if iBT.what.stats.Confounds_mask_timecourse.do
  

  if ( iBT.what.stats.fc.do == 1 ),

    %-----------------------------------------------------------------------
    %  Get pre-calculated seed time-courses of interest
    %-----------------------------------------------------------------------

    if (iBT.what.stats.fc.timecourse.do ~= 0 ),
        if strcmp(iBT.what.SpmVersion, 'SPM2')
            VOI = spm_get('files',ROI_loc,iBT.who.sub{sub}.sess{ses}.Regressor_files);
        else
            VOI = spm_select('fplist',ROI_loc,spm_wildconvert(iBT.who.sub{sub}.sess{ses}.Regressor_files));
        end; %strcmp(iBT.what.SpmVersion, 'SPM2')

        nseedsTC = size(VOI,1); % Total number of seeds specified via pre-calculated timecourses
        for s = 1:nseedsTC
    
          if (iBT.what.stats.fc.timecourse.do == 1 ),
            % Using iBrain extracted time-course
            %Y = textread(deblank(VOI(s,:)));
	    fidY = fopen(deblank(VOI(s,:)));
	    Y = textscan(fidY,'%f');
	    Y=Y{1};
	    fclose(fidY);
          else
            % Using SPM extracted VOI time-course
            load(deblank(VOI(s,:)));
	  end
	  
            if (numel(Y) > nvolumes(session))
                Y = Y(pick{session});
		disp('Regressor lengths exceeded selected data length, so pick range has now been applied to the regressors');
	    end
	    if (numel(Y) < nvolumes(session))
	        error('Error: Regressor length is shorter than data length');
            end
     	    
            [dirname, fname] = fileparts(deblank(VOI(s,:)));
	    if (iBT.what.stats.fc.put_first == 0 ),
            	SPM.Sess(session).C.C = [SPM.Sess(session).C.C ((Y-mean(Y(:)))./std(Y(:)))]; % Regressor of interest is standardised and put last
            	SPM.Sess(session).C.name = {SPM.Sess(session).C.name{:} fname};
	    else
            	SPM.Sess(session).C.C = [((Y-mean(Y(:)))./std(Y(:))) SPM.Sess(session).C.C ]; % Regressor of interest is standardised and put first
            	SPM.Sess(session).C.name = {fname SPM.Sess(session).C.name{:}};
	    end	    
            nseedsOfInterest = nseedsOfInterest + 1;

            disp(['Seed(' num2str(nseedsOfInterest) ') = ' fname]);
        end %for
    end; % if (iBT.what.stats.fc.timecourse.do == 1 ),


    if (iBT.what.stats.fc.ROI_mask_timecourse.do == 1 ),
    %---------------------------------
    %  Get timecourses from ROI masks. These are placed after all the confounds and seeds already defined.
    %---------------------------------
      if strcmp(iBT.what.SpmVersion, 'SPM2')
        VOI = spm_get('files',ROI_loc,iBT.who.sub{sub}.sess{ses}.ROI_mask);
      else
        VOI = spm_select('FPlist',ROI_loc,spm_wildconvert(iBT.who.sub{sub}.sess{ses}.ROI_mask));
      end

      VY = spm_vol(SPM.xY.P);
      for i=1:size(VOI,1)
        VM = spm_vol(VOI(i,:));

        [X Y Z] = meshgrid(1:VY(1).dim(1),1:VY(1).dim(2),1:VY(1).dim(3));

        %  Transform into voxel coordinates in mask image
        vox = [X(:) Y(:) Z(:) ones(numel(X),1)]';
        vox = VY(1).mat*vox;
        vox = inv(VM.mat)*vox;

        %  Sample from the mask image
        mask = spm_sample_vol(VM, vox(1,:), vox(2,:), vox(3,:), 0);

        %  Choose the coordinates in the target image where the mask
        %  is greater than zero.
        X = X(find(mask > 0));
        Y = Y(find(mask > 0));
        Z = Z(find(mask > 0));

        R = zeros(length(VY),1);
        for t = 1:length(VY)
            R(t) = mean(spm_sample_vol(VY(t),X(:),Y(:),Z(:),0));
        end
	if (iBT.what.stats.fc.put_first ~= 0 ),
        	SPM.Sess(session).C.C = [SPM.Sess(session).C.C ((R-mean(R(:)))./std(R(:)))];
        	SPM.Sess(session).C.name = {SPM.Sess(session).C.name{:} VM.fname};
	else
        	SPM.Sess(session).C.C = [((R-mean(R(:)))./std(R(:))) SPM.Sess(session).C.C];
        	SPM.Sess(session).C.name = {VM.fname SPM.Sess(session).C.name{:}};
	end
        nseedsOfInterest = nseedsOfInterest + 1;
        disp(['Seed(' num2str(nseedsOfInterest) ') = ' VM.fname]);
      end
      clear VY;
    end; % if iBT.what.stats.fc.ROI_mask_timecourse.do


    if (iBT.what.stats.fc.voxel.do == 1 ),

        %  Use a time-series centered on a voxel if iBT.what.stats.fc.voxel has been specified 
        %  This is assumed to be a voxel of interest and will end up last of all regressors
	%  Specifying confound seed voxels in this way is not yet supported. Please use timecourse
	%  files and/or timecourse mask images to generate confounds (or extend this code!).

        centre = iBT.who.sub{sub}.sess{ses}.ROI_coord;
        radius = iBT.who.sub{sub}.sess{ses}.ROI_radius;

        VY = spm_vol(SPM.xY.P);
	
	if strcmp(iBT.who.sub{sub}.sess{ses}.ROI_coord_units,'mm')
          disp(['Creating a sphere ROI centred at (' num2str(centre(1)) ',' num2str(centre(2)) ',' num2str(centre(3)) ')mm with radius = ' num2str(radius) ' mm']);
	  % if centre is specified in mm; need to convert into a voxel-space co-ordinate for iBT_sphere_roi
          imat = inv(VY(1).mat);
          centre_voxel = imat(1:3,:)*[centre 1]'; % centre_voxel is in units of voxels
	else
	  centre_voxel = centre;
	end
        disp(['Centre voxel of sphere ROI is (' num2str(centre_voxel(1)) ',' num2str(centre_voxel(2)) ',' num2str(centre_voxel(3)) ') voxels']);

        XYZ = iBT_sphere_roi(radius, voxel_size, centre_voxel); %(radius mm, voxel_size mm, centre voxels, XYZ voxels)

        Y = zeros(length(VY),size(XYZ,2));
        for t = 1:length(VY)
            Y(t,:) = spm_sample_vol(VY(t),XYZ(1,:),XYZ(2,:),XYZ(3,:), 0);
        end

        clear VY;
        Y = mean(Y,2);
        seedname_tmp = sprintf('(%0g,%0g,%0g)r=%gmm',centre(1), centre(2),centre(3),radius);
	if (iBT.what.stats.fc.put_first ~= 0 ),
        	SPM.Sess(session).C.C = [SPM.Sess(session).C.C ((Y-mean(Y(:)))./std(Y(:)))];
        	SPM.Sess(session).C.name = {SPM.Sess(session).C.name{:} seedname_tmp};
	else
        	SPM.Sess(session).C.C = [((Y-mean(Y(:)))./std(Y(:))) SPM.Sess(session).C.C];
        	SPM.Sess(session).C.name = {seedname_tmp SPM.Sess(session).C.name{:}};
	end
        nseedsOfInterest = nseedsOfInterest + 1;
        disp(['Seed(' num2str(nseedsOfInterest) ') = ' seedname_tmp]);
    end; % if (iBT.what.stats.fc.voxel.do == 1 )

    disp(['Total number of seeds of interest: ' num2str(nseedsOfInterest)]);
    
  end; % if ( iBT.what.stats.fc.do == 1 ),

end; %for ses


if ~strcmp(iBT.what.SpmVersion, 'SPM2')
    cd(cwd);
end

if iBT.what.stats.design.configure == -1

  % Notwithstanding anything we've done to SPM above, we'll now 
  % load what we had before. We needed to do some of the stuff
  % above to set other variables that are used in
  % contrasts generation later.
 
  disp 'Loading existing SPM.mat...'
  load('SPM.mat');
  disp 'Done.'

elseif iBT.what.stats.design.configure == 1


  % Configure design matrix
  %===========================================================================

  SPM = spm_fmri_spm_ui(SPM);

  % Save figures of the SPM configured design matrix 
  % (this includes the orthogonalisation of event delay and dispersion regressors that SPM performs)
  %===========================================================================
  spm_figure('Close','Graphics') % First close the graphics window, otherwise the SPM welcome screen may appear overlaid on the output.
  fname = reshape(cellstr(SPM.xY.P),size(SPM.xY.VY)); spm_DesRep('DesMtx',SPM.xX,fname,SPM.xsDes); % Reload the design matrix.
  if (iBT.what.stats.design.savePreliminaryFig == 1 )
	  spm_print([iBT.what.SpmVersion '_preliminary_design.ps'],'Graphics','ps'); % Save PostScript version
	  spm_print([iBT.what.SpmVersion '_preliminary_design.png'],'Graphics','png'); % Save PNG version
	  spm_print([iBT.what.SpmVersion '_preliminary_design.fig'],'Graphics','fig'); % Save MATLAB .fig version
	end % if iBT.what.stats.design.savePreliminaryFig
 
  % Explicit masking
  %===========================================================================
  if exist('Explicit_mask_fname','var')
    % set the SPM.xM.TH values all to -Inf,
    SPM.xM.TH = -Inf*SPM.xM.TH;
    % and, in case we have an image format not allowing NaNs,
    SPM.xM.I = 0;
    % Use a mask image, by setting SPM.xM.VM to a vector of structures,
    % where each structure element is the output of spm_vol.
  
    SPM.xM.VM = spm_vol(Explicit_mask_fname);
  end % if do_ExplicitMask 

  if (iBT.what.stats.fc.do == 1 ),
    %-----------------------------------------------------------------------
    % Band-pass filter
    %-----------------------------------------------------------------------

    cumulativeRowCount = 1;
    for session=1:nsess
      K(session).RT = SPM.xY.RT;
      K(session).HParam = iBT.what.fc.HParam;
      K(session).LParam = iBT.what.fc.LParam;
      K(session).row = [cumulativeRowCount:cumulativeRowCount - 1 + SPM.nscan(session)];
      cumulativeRowCount = cumulativeRowCount + SPM.nscan(session);
    end
    K = iBT_spm_filter(K);
    SPM.xX.K =  K;
  
  end; %(iBT.what.stats.fc.do == 1 ),

end % if iBT.what.stats.design.configure == 1
if iBT.what.stats.design.configure ~= 0 % Even if we've already configured a design, we need to do the next bit again so that iC and iG are defined for use in contrast generation later.

  %  
  %  Specify the effects of no interest (motion parameters etc)
  %===========================================================================
  %  SPM.xX.iH = indicator variables 
  %  SPM.xX.iC = covariates 
  %  SPM.xX.iB = block effects 
  %  SPM.xX.iG = nuisance variables
  %
  %  NOTE: We only need to worry about iC and iG
  %

 for session=1:nsess
	if iBT.what.stats.fc.do == 0,
	  iC{session} = [1:neffect{session}*((SPM.xBF.order*(parametric_count+1))^bf_convolution)];
	  iG{session} = [1:size(SPM.Sess(session).C.C, 2)] + iC{session}(end);
	else 
	  % With connectivity, we have confound seeds and seeds of interest. The seeds of interest occupy 
	  % the last nseedsOfInterest columns.
	  % We also retain block and/or event-related effects as effects of interest if specified. These occupy 
	  % the first-most columns. The confounds are all those in between.
	  iG{session} = [1:size(SPM.Sess(session).C.C, 2)  - nseedsOfInterest] + length(SPM.Sess(session).U)*SPM.xBF.order;
          iC{session} = [[1:length(SPM.Sess(session).U)*SPM.xBF.order] [1:nseedsOfInterest] + iG{session}(end)];
	end
	
	% sanity check - do we have enough degrees of freedom to estimate?
	df_used{session} = length(iC{session}) + length(iG{session}) + 1; % +1 is for the session mean column
	if  nvolumes(session) - df_used{session} < 3
	  disp ' ' 
	  disp '***********************************************************************' 
 	  disp(sprintf('WARNING: Too few degrees of freedom in session %d',session))
 	  disp(sprintf('         %d data points - %d effect - %d confound - session mean',nvolumes(session),length(iC{session}),length(iG{session}) ))
 	  disp(sprintf('         = %d degrees of freedom. Will skip this analysis.',nvolumes(session) - df_used{session} ))
	  disp '***********************************************************************' 
	  disp ' ' 
	  cd(start_cwd);
 	  return
	end; % 
 end; %for session

end % if iBT.what.stats.design.configure ~= 0
if iBT.what.stats.design.configure == 1

 SPM.xX.iC = iC{1};
 SPM.xX.iG = iG{1};
 column_session(1: length(iC{1}) + length(iG{1}) ) = 1; %These design matrix columns belong to the first session
 offset(1) = 0; % The offset into design matrix to get up to first session is zero.
 if nsess > 1
      for session=2:nsess; %complete the matrix with remaining sessions
  	offset(session) = length(SPM.xX.iC) + length(SPM.xX.iG); %Number of columns in matrix so far
 	SPM.xX.iC = [SPM.xX.iC (offset(session) + iC{session})];
	SPM.xX.iG = [SPM.xX.iG (offset(session) + iG{session})];
	column_session(offset(session)+1:offset(session) + length(iC{session}) + length(iG{session})) = session; %These design matrix columns belong to this session
      end; %for session
    end; %if nsess > 1

  %
  %  Orthogonalise the regressors
  %
  if orth_regressors % Consider this experimental at this stage
    if orth_regressors == 1
        %  This orthogonalises the basis function regressors for each
        %  effect of interest separately (useful for example if you have delay and/or dispersion terms)
        disp(sprintf('Orthogonalising basis function regressors with respect to their main effect of interest...'))
        for session = 1:nsess % for each session
            for i = 1:length(SPM.Sess(session).Fc) % for each contrast group of regressors in the session
	    	disp(sprintf('Orthogonalising the following regressors in session %i:',session));
		disp(SPM.Sess(session).Fc(i).i);
		if session > 1
	    		disp('  which are in the following design matrix columns respectively:');
			disp(offset(session) + SPM.Sess(session).Fc(i).i);
		end
                SPM.xX.X(:,offset(session) + SPM.Sess(session).Fc(i).i) = spm_orth(SPM.xX.X(:,offset(session)+SPM.Sess(session).Fc(i).i));
            end %for i = 1:length
        end %for session = 1:size
    elseif orth_regressors == 2
        %
        %  This orthogonalises all regressors in turn following the first.
	%  For connectivity, if the seed regressors of interest are specified last,
	%  then this is probably the option you want to use, so that all other
	%  effects are "regressed out" of the seed timecourses so the connectivity
	%  result will reflect only what is left over after all other regressors
	%  are taken into account. However consider also option 2.1 below.
        %
        disp(sprintf('Orthogonalising all regressors with respect to the first...'))
        SPM.xX.X(:,:) = spm_orth(SPM.xX.X(:,:));
    elseif orth_regressors == 2.1
        %
        %  Similar to option 2 above, EXCEPT the very last regressor is left unchanged.
	%  This may be useful, for example, if the last regressor in the model is a 
	%  contant and you want to leave that intact.
        %
        disp(sprintf('Orthogonalising all regressors (except the very last) with respect to the first...'))
        SPM.xX.X(:,1:1:end-1) = spm_orth(SPM.xX.X(:,1:1:end-1));
    elseif orth_regressors == 3
        % This orthogonalises all regressors in reverse-order of the design matrix.
    	temp = SPM.xX.X(:,end:-1:1);
        temp(:,:) = spm_orth(temp(:,:)); % Orthogonlise it.
	SPM.xX.X = temp(:,end:-1:1); % Put back in original order
    elseif orth_regressors == 4
        %
        % This orthogonalises all regressors, with regressor(s) of no interest orthogonalised first,
	% followed by all regressors of interest. This is a conservative way to examine any effects of 
	% interest as all other confounding effects are "regressed out" of the effects of interest: the
	% effects of interest are changed so that they  will reflect only what is left over
	% after all other regressors are taken into account. During the orthogonalisation process the
	% the relative order of the effects of interest are not changed with respect to other effects of interest,
	% and similarly the relative order of effects of no-interest are maintained with respect to other effects 
	% of no interest. Thus the last effect of interest specified in the design will also be the last regressor
	% to be orthogonalised, and the first regressor specified that is not of interest will be the only 
	% regressor not changed due to the serial nature of the orthogonalisation process.
	% Note that if delay and dispersion are in the model then these are also considered effects of interest.
        %
        disp(sprintf('Orthogonalising all regressors (effect(s) of interest orthogonalised last)...'))
	% SPM.xX.iC are indices of the design matrix columns containg regressors of interest
	not_iC = [1:size( SPM.xX.X,2)]; not_iC(SPM.xX.iC) = []; % All the other regressors are of no interest.
	temp = [SPM.xX.X(:,not_iC), SPM.xX.X(:,SPM.xX.iC)]; % Create a temp design with regressors of interst at the end
        temp(:,:) = spm_orth(temp(:,:)); % Orthogonlise it.
        % Put now-orthogonalised effects of interest back where they were:
	SPM.xX.X(:,not_iC) = temp(:,1:length(not_iC)); % Regressors of no interest
	SPM.xX.X(:,SPM.xX.iC) = temp(:,length(not_iC)+1:length(not_iC)+length(SPM.xX.iC)); % Regressors of interest
    elseif orth_regressors == 4.1
        %
				%  Similar to option 4 above, EXCEPT any session block effects (constant terms) are left unchanged.
        %
        disp(sprintf('Orthogonalising all regressors (except session constant) (effect(s) of interest orthogonalised last)...'))
	% SPM.xX.iC are indices of the design matrix columns containing regressors of interest
	% SPM.xX.iB are indices of the design matrix columns containing session block effects (the constant term)
	not_iC = [1:size( SPM.xX.X,2)]; not_iC(SPM.xX.iB) = []; not_iC(SPM.xX.iC) = [];% First remove the constant term, then the regressors of interest. All the other regressors are of no interest.
	temp = [SPM.xX.X(:,not_iC), SPM.xX.X(:,SPM.xX.iC)]; % Create a temp design with regressors of interst at the end
        temp(:,:) = spm_orth(temp(:,:)); % Orthogonlise it.
        % Put now-orthogonalised effects of interest back where they were:
	SPM.xX.X(:,not_iC) = temp(:,1:length(not_iC)); % Regressors of no interest
	SPM.xX.X(:,SPM.xX.iC) = temp(:,length(not_iC)+1:length(not_iC)+length(SPM.xX.iC)); % Regressors of interest        %
    end %if orth_regressors == else
  else
  	if iBT.what.stats.fc.do == 1
		disp('WARNING: Regressor orthogonalisation is disabled, yet this is a functional')
		disp('         connectivity analysis. Are you sure this is what you want?')
	end
  end %if orth_regressors

  % Print design matrix summary
  switch (iBT.what.SpmVersion),
    case 'SPM2',
      global defaults; % Give us access to the SPM defaults variable.
      original_printstr = defaults.printstr;
      defaults.printstr = [spm_figure('DefPrintCmd'), 'spm2_design.ps' ]; 
      spm_print;
      defaults.printstr = original_printstr;
    otherwise,
      spm_figure('Clear','Graphics') % Clear the graphics window
      fname = reshape(cellstr(SPM.xY.P),size(SPM.xY.VY)); spm_DesRep('DesMtx',SPM.xX,fname,SPM.xsDes); % Reload the design matrix in the graphics window now that any additional orthogonalisation has been performed.
      spm_print([iBT.what.SpmVersion '_ibt_design.ps'],'Graphics','ps'); % Save PostScript version
      spm_print([iBT.what.SpmVersion '_ibt_design.png'],'Graphics','png'); % Save PNG version
      spm_print([iBT.what.SpmVersion '_ibt_design.fig'],'Graphics','fig'); % Save MATLAB .fig version
  end

  if iBT.what.stats.estimate == 0
        disp(sprintf('Saving design without estimating the model...'))
        fmt = spm_get_defaults('mat.format');
        s = whos('SPM');
        if s.bytes > 2147483647, fmt = '-v7.3'; end
        save('SPM.mat', 'SPM', fmt);
        fprintf('%30s\n','...SPM.mat saved');
  end
  
end % if iBT.what.stats.design.configure == 1


if iBT.what.stats.estimate == 1

  if (iBT.what.stats.design.configure == 0) 
	throw(MException('iBT_stats:estimate', 'No model to estimate because iBT.what.stats.design.configure is 0' ));
  else
	% Estimate parameters
	%===========================================================================

				if ~iBT.what.disp.fix_for_SPM12r6906_applied
				  if ( strcmp(iBT.what.SpmVersion, 'SPM12') && ((iBT.what.SpmRelease >= 6906) && (iBT.what.SpmRelease < 6913)) )
				  ; % The SPM12 public release 6906 (20 October 2016) had a bug in spm_est_non_sphericity.m that caused it to 
				  ; % crash if explicit masking was used.
				  ; % A patch was quickly released on the mailing list, but given the slow public-release SPM update cycle we included
				  ; % the patch here to save people the trouble. We now keep it here for those still using SPM12 r6906. 
				  ; % According to the SPM12 changelog, the bug was fixed in r6913, but this only became generally 
				  ; % available in public release 7219 (16 November 2017), more than a year after the dodgy release.
					iBT.what.disp.fix_for_SPM12r6906_applied = 1; %So we know that we don't need to do this again this session
					[pathstr,name,ext]=fileparts(which('iBT_stats'));
					newpath = fullfile(pathstr,'fix_for_SPM12r6906');
  					addpath(newpath);
  					disp(['Added ' newpath ]);
  					disp(['  to Matlab path to avoid bug introduced in SPM8_r6906.']);
				  end
				end %if ~iBT.what.disp.fix_for_SPM12r6906_applied


	disp(sprintf('Estimating parameters...'))
	SPM = spm_spm(SPM)
        disp(sprintf('Saving SPM.mat...'))
	fmt = spm_get_defaults('mat.format');
	s = whos('SPM');
	if s.bytes > 2147483647, fmt = '-v7.3'; end
	save('SPM.mat', 'SPM', fmt);
	fprintf('%30s\n','...SPM.mat saved');

  end

  if (iBT.what.stats.denoised.SOCK.adjust_erdf == 1 )
        total_SOCK_artifacts = sum(SOCK.len_artifacts(1:end));
	disp(sprintf('Subtracting %i from SPM.xX.erdf to account for SOCK regressors used in denoising',total_SOCK_artifacts))
	disp(sprintf(' ( SPM.xX.erdf was %g, now %g )',SPM.xX.erdf, SPM.xX.erdf - total_SOCK_artifacts))
	SPM.xX.erdf = SPM.xX.erdf - total_SOCK_artifacts;
  end; % if (iBT.what.stats.denoised.SOCK.adjust_erdf == 1 )
  
  if (iBT.what.stats.denoised.adjust_erdf < 0 )
	disp(sprintf('Subtracting %i from SPM.xX.erdf to account for regressors used in denoising',-iBT.what.stats.denoised.adjust_erdf))
	disp(sprintf(' ( SPM.xX.erdf was %g, now %g )',SPM.xX.erdf, SPM.xX.erdf + iBT.what.stats.denoised.adjust_erdf))
	SPM.xX.erdf = SPM.xX.erdf + iBT.what.stats.denoised.adjust_erdf;
  end; % if (iBT.what.stats.denoised.adjust_erdf == 1 )
 
end % if iBT.what.stats.estimate

% Most from now on requires an estimated design. If this will be required, 
% check now to see if the design has been estimated.
if (iBT.what.stats.event_con > 0)  || (iBT.what.stats.evalCons > 0)
    try, SPM.Vbeta.fname; estimated = 1; catch estimated = 0; end
    if ~estimated,
      disp ' ' 
      disp '***********************************************************************' 
      disp(sprintf('WARNING: No betas present - it looks like the model has not'))
      disp(sprintf('         yet been estimated. '))
      disp '***********************************************************************' 
      disp ' ' 
	if iBT.what.error.stop > 0
	      	  throw(MException('iBT_stats:evalCons','Unable to continue (see message above)' ));
	end
    end; % if ~estimated
end %if (iBT.what.stats.event_con > 0) || (iBT.what.stats.evalCons > 0)

if iBT.what.stats.event_con > 0 
 % SPM.xX.iC provides column indicies of effects of interest. We'll
 % create a positive and a negative T contrast for each effect.
 % We determine appropriate naming for the effects by using
 % our earlier design construction.
 %
 if iBT.what.stats.event_con == 2 disp(sprintf('Configuring individual contrasts for each effect of interest...'));
 else disp(sprintf('Configuring individual contrasts for each primary effect of interest...')); 
 end

 clear cnam cwgt ctyp cw
 switch (iBT.what.SpmVersion),
   case 'SPM2',
     ocon = length(SPM.xCon);	% current contrasts (e.g. defaults and any others added since)
     ncols = size([SPM.xCon.c],1);  % number of columns in the design matrix
   otherwise,
     ncols = size(SPM.xX.name,2);  % number of columns in the design matrix
 end

 session = 1; %initialise
 offset = 1;  %initialise
 skip_effect = 0; %initialise
 event = 1; %initialise

 if (iBT.what.stats.fc.do == 0),
   Neffects = length(SPM.xX.iC);
 else
   Neffects = nseedsOfInterest;
 end

 for effect = 1:Neffects;
   if effect > skip_effect
 	% work out which session we're in so can name appropriately
	while SPM.xX.iC(effect) >= offset  %this will always run through at least once the first time
	  offset = offset + length(iC{session}) + length(iG{session});
	  session = session + 1;
	  nidx = 1; %initialise index into names for a new session	
	end
 	% At this point, session and offset will be for the NEXT session.
	num_regressors = length(iC{session-1}) + length(iG{session-1}); % number of columns in THIS session. 
	
	cnam{event} = sprintf('Sess(%d):+effect(%d):%s,%s,col=%d', session-1,effect,params{session-1}.ID,char(SPM.xX.name(SPM.xX.iC(effect))),SPM.xX.iC(effect));
	cwgt{event} = zeros(1,ncols);
	cwgt{event}( SPM.xX.iC(effect) ) = 1;
	ctyp{event} = 'T';

	% create negative contrasts
	cnam{event + 1} = sprintf('Sess(%d):-effect(%d):%s,%s,col=%d', session-1,effect,params{session-1}.ID,char(SPM.xX.name(SPM.xX.iC(effect))),SPM.xX.iC(effect));
        cwgt{event + 1} = -cwgt{event};
        ctyp{event + 1} = ctyp{event};
	nidx = nidx + 1;

   	event = event + 2; % Ready for the next (+2 because there are + & - contrasts for each event)
	
	if iBT.what.stats.event_con == 1
 	  % skip any secondary effects of interest (i.e. event convolved with additional basis functions etc.)
          if (iBT.what.stats.fc.do == 0),
 	   % skip_effect = effect + ((SPM.xBF.order*(parametric_count+1))^bf_convolution) -1;
	   % We now don't skip parametrically modulated main effects if present, because they are likely also of interest - (dfa, 2021-02-02):
 	    skip_effect = effect + ((SPM.xBF.order)^bf_convolution) -1;
          else
	    % This is not really correct. What we need to do here is skip as above if it is a block or event related effect, or as here if it is a fc effect.
	    % Therefore this code needs to be expanded if we ever want to support parametric_modulation_by_separation of block and event-related effects whilst also having fc regressors (which are not modulated)
            % skip_effect = effect;
          end
	end
   end; %if event > skip_effect
 end; %for

 try, num_extra = numel(iBT.what.stats.extra_con.name); % We've some extra contrasts specified in terms of combinations of effects of interest
 catch
 	num_extra = 0;
 end% try, iBT.what.stats.extra_cons

 if num_extra > 0,
      for ec=1:num_extra  % loop over all requested extra contrasts
	ec_length = numel(iBT.what.stats.extra_con.weight{ec}); % number of effects of interest we need to set (remainder padded to zero)
	try, test=numel(SPM.xX.iC(1:ec_length)); % check indicies into the design matrix where the elements of ec apply - if this fails then the regressors requested do not exist so skip.
	catch
		test = 0;
		disp(sprintf('Warning: Ignoring extra contrast number %i which extends beyond available regressors of interest.',ec))
	end % catch
	if test > 0,
	  cnam{event} = iBT.what.stats.extra_con.name{ec};
	  cwgt{event} = zeros(1,ncols); % Pad all with zero to initialise
	  cwgt{event}( SPM.xX.iC( 1:ec_length) ) = iBT.what.stats.extra_con.weight{ec}; % set just the specified elements
	  ctyp{event} = iBT.what.stats.extra_con.type{ec};
   	  event = event + 1; % Ready for the next (we don't automatically create negative versions for the extra contrasts)
	end % if test > 0
      end % for	
 end % if num_extra > 0,

 switch (iBT.what.SpmVersion),
   case 'SPM2',
     for c = 1:length(cnam)
       cw = [cwgt{c}]';	% 
       SPM.xCon(c+ocon)     = spm_FcUtil('Set',cnam{c},ctyp{c},'c',cw,SPM.xX.xKXs);
     end

   otherwise,
     if isfield(SPM,'xCon'), SPM = rmfield(SPM,'xCon'); end % remove existing empty xCon structure so we can create our own
     for c = 1:length(cnam)
       cw = [cwgt{c}]';	% 
       SPM.xCon(c)     = spm_FcUtil('Set',cnam{c},ctyp{c},'c',cw,SPM.xX.xKXs);
     end
 end
 
 disp(sprintf('Done.'));
end; %if  (iBT.what.stats.event_con == 1)

if motion_rejection && (~strcmpi(iBT.what.stats.events.source,'none')) && (iBT.what.stats.mc.rejLog ~= 0), % Log some information about motion rejection regressors in relation to events
  try, column_session; % if we know this already, use it
 	mrej = iBT_mrej(SPM, iBT.what.stats.mc.rejLog, iBT.who.sub{sub}.ID, column_session);
  catch
 	mrej = iBT_mrej(SPM, iBT.what.stats.mc.rejLog, iBT.who.sub{sub}.ID);
  end
  
end %if motion_rejection && ...

% And evaluate
%===========================================================================
if iBT.what.stats.evalCons > 0
	spm_contrasts(SPM);
elseif iBT.what.stats.evalCons == 0
	disp 'Contrasts not evaluated (iBT.what.stats.evalCons is 0), so you may need to run spm manually to evaluate contrasts'
end; %if iBT.what.stats.event_con > 0 else

end; %if  ( iBT.what.stats.make_data_links_only == 0 )

cd(start_cwd);

function new_str = spm_wildconvert(orig_str)
%
% Sub function to convert normal wildcards to a regexp format for spm*
%
% Modification History
% ---------------------
%
% 2008-08-21 - matt: Function creation

new_str =  strcat('^', orig_str, '$');
new_str = strrep(new_str,'.','\.');
new_str = strrep(new_str,'?','.');
new_str = strrep(new_str,'*','(.*)');
