function mrej = iBT_mrej(SPMmat, VERBOSE, ID, column_session)
% For each regressor of interest, determine how many scans
% effectively image a "task" state and how many effectively
% image a "rest" state, and determine the extent to which
% scans rejected via motion rejection regressors has diminished the
% number of "task" and "rest" images in this study. The terms task
% and rest are used loosely - the mean of the minimum and maximum
% values in the regressor column is used for an initial split,
% and to improve outlier control the median above and below this is
% then averaged to obtain a new threshold to split the data into
% task and rest. This classification may not make much sense when
% it comes to derived additional regressors such as delay or
% dispersion derivatives.
%
% The function requires input SPMmat to be either an SPM structure
% with a properly configured design matrix, or the name of an SPM.mat
% file containing such a structure. It is assumed that within it the
% rejection regressors have names like "Sn(1) Reject" as created by
% iBt.
%
% Returns results in a structure with (hopefully) self-explanatory
% fields (uses terms active for task and inactive for rest), or see
% also the last few lines of this .m file for comments.
%
%___________________________________________________________________________
% Copyright 2013 The Florey Institute of Neuroscience and Mental Health
%
% This file is part of iBT (the Integrated Brain Analysis Toolbox for SPM).
% See iBT_SPM.m for more information.

% iBT is free software: you can 
% redistribute it and/or modify it under the terms of the GNU General 
% Public License as published by the Free Software Foundation, either
% version 3 of the License, or (at your option) any later version.
% 
% iBT is distributed in the hope 
% that it will be useful, but WITHOUT ANY WARRANTY; without even the  
% implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
% PURPOSE.  See the GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program. If not, see <http://www.gnu.org/licenses/>.
%___________________________________________________________________________
%
% Recent Version History:
% 2013-12-09: (dfa) Log name of regressor of interest. Change 2nd arg
%               to VERBOSE to allow different levels of verbosity and
%		add ID string argument to better label output.
% 2013-11-11: (dfa) Support passing an SPM structure to save loading
%		from file, and optional column_session array to
%		save effort if called from iBT_stats().
% 2013-11-04: (dfa) Fix crash if no contrasts of interest
% 2013-10-22: (dfa) Original version by David Abbott, based on code 
% 		he originally deployed in iBT_stats(). The
%		present version requires only SPM.mat as input and
%		assumes the session mean columns appear last in the
%		design matrix order and have at least one non-zero
%		row in each session. This should work for most
%               usual block and event-related designs.
%

try, SPMmat; catch SPMmat = 'SPM.mat'; end
try, VERBOSE; catch VERBOSE = 1; end
try, ID; catch ID = ''; end

if isstruct(SPMmat), 
   SPM=SPMmat;
   SPMmatfilename = ['SPM structure from ' SPM.swd];
else 
   if numel(SPMmat) == 0, SPMmatfilename = fullfile(pwd,'SPM.mat'); else SPMmatfilename = SPMmat; end
   if exist(SPMmatfilename,'file')==2,
 	if VERBOSE, disp 'Loading existing SPM.mat...'; end
 	load(SPMmatfilename);
 	if VERBOSE, disp 'Done.'; end
   else
 	if VERBOSE, disp(['Warning(iBT_mrej): File not found: ' SPMmatfilename]); end
	mrej = 0;
	return
   end
end %if isstruct(SPMmat)
  
%
%  Find motion-rejection regressors and set associated timecourse values to NaN
%
mrejCell = regexp(SPM.xX.name,'Sn\((.*)\) Reject'); % We are looking for regressors names like "Sn(1) Reject"
mrejIndex = find(not(cellfun('isempty', mrejCell))); % Applicable design matrix column numbers
if isempty(mrejIndex)
      if VERBOSE, disp(['No motion rejection regressors found in ' SPMmatfilename]); end
      rejected = zeros(size(SPM.xX.X,1),1); % none rejected
else

  if VERBOSE, disp(sprintf('Found %i motion rejection regressors.',numel(mrejIndex))); end

  mid = (max(SPM.xX.X(:,mrejIndex)) - min(SPM.xX.X(:,mrejIndex)))/2 + min(SPM.xX.X(:,mrejIndex)); % Mid point of rejection regressors (in case they may have been centred)

  rejected = sum( SPM.xX.X(:,mrejIndex) > mean(mid) , 2) * 1; % Binarise the rejection regressors then project (sum) across columns, *1 to convert to non-logical type.

  if max(rejected) > 1 
       if VERBOSE, disp('Warning: Some rejection regressors overlap (this should not happen for anaylses generated by iBT)'); end
  end
end; %if isempty(mrejIndex) else

if (max(rejected) > 0) || (VERBOSE == 2), % There is something to do
 try, column_session;
 catch
   % Work out which design matrix columns pertain to each session
   binDM = (SPM.xX.X ~=0) * 1; % is a binarised design matrix, * 1 to convert to non-logical type.
   num_cols = size(binDM,2);  % Number of columns in the design matrix
   num_ses = numel(SPM.xX.K); % Number of sessions in the design matrix
   for ses = 1:num_ses
		% Use the session's mean column to determine which rows are relevant for this session
		% (assumes the session mean columns apepear last in the design matrix).
		column_session( ((binDM(:,num_cols - num_ses + ses)' * binDM ) > 0) ) = ses; 
   end
 end % try, column_session; catch
 
 for rin=1:size(SPM.xX.iC,2) % loop over all regressors of interest 
  	ric = SPM.xX.iC(rin); % Column of design matrix corresponding to the rinTH regressor of interest. 	
	session = column_session(ric); % Session for which this column pertains	
	% range of rows for this session (will be all rows for single-session designs, part of a row for multi-session designs)
	range=SPM.xX.K(session).row;
	if VERBOSE, disp(sprintf('Classifying scans as "task" or "rest" based on thresholding regressor of interest %i (design column %i: "%s")...',rin,ric,SPM.xX.name{ric})); end
	% Elements in the column of design matrix that are greater than or equal to the
	% middle of their range:
	min_act = min(SPM.xX.X(range,ric));
	max_act = max(SPM.xX.X(range,ric));
 
	mid_point = mean( [min_act , max_act] );
	if VERBOSE, disp(sprintf('  Regressor ranges between %g and %g, mean = %g',min_act, max_act, mid_point)); end

	active = SPM.xX.X(range,ric) >= mid_point;
	inactive = 1 - active;

	% Whilst the mid-range threshold above should work reasonably well, we can 
	% improve our estimate by calculating the median of the values in each category.
	tmp_active = SPM.xX.X(range,ric) .* active; % Zero the first estimate of "inactive" values,
	tmp_active(tmp_active==0)=[]; % remove elements from the array if zero,
	median_active = median(tmp_active); % and calculate median (of the first estimate of "inactive" values)
	tmp_inactive = SPM.xX.X(range,ric) .* inactive; % Zero the first estimate of "active" values,
	tmp_inactive(tmp_inactive==0)=[]; % remove elements from the array if zero,
	median_inactive = median(tmp_inactive); % and calculate median (of the first estimate of "inactive" values)
	mid_point = mean([median_active,median_inactive]); % A new mid point, half way between these two medians.

	if VERBOSE, disp(sprintf('  adjusting threshold mid point to %g based on median of values above and below initial threshold.',mid_point)); end

	% redefine active and inactive based on this new mid point.
	active = SPM.xX.X(range,ric) >= mid_point;
	inactive = 1 - active;

	num_active = sum(active); % number of scans in which the BOLD response is expected to be "active"
	num_inactive = sum(inactive); % number of scans in which the BOLD response is expected to be "inactive"
	
	% how many "active" scans remain after motion rejection regressors?
	active_rejected = active .* rejected(range);
	num_active_rejected = sum(active_rejected);

	% how many "inactive" scans remain after motion rejection regressors?
	inactive_rejected = inactive .* rejected(range);
	num_inactive_rejected = sum(inactive_rejected);

	if ( ~isempty(mrejIndex) ) || (VERBOSE == 2)
		% Display a summary of these results:
		if VERBOSE, disp(sprintf('  motion rejection effectively removes %4i of %4i "task" scans and %4i of %4i "rest" scans from %s design column %4i "%s".',num_active_rejected,num_active,num_inactive_rejected,num_inactive,ID,ric,SPM.xX.name{ric})); end
	end; %if ~isempty(mrejIndex)
	
	% Create a cell structure indexed by the design matrix column number so easy for others to access this information
	mrej{ric}.mrej_version = '1.0';
	mrej{ric}.column = ric; % Design matrix column number
	mrej{ric}.name = SPM.xX.name{ric}; % Design matrix column name
	mrej{ric}.session = session; % Session number
	mrej{ric}.active = int8(active); % Array with 1's indicating effectively "task" scans, before motion rejection.
	mrej{ric}.inactive = int8(inactive); % Array with 1's indicating effectively "rest" scans, before motion rejection.
	mrej{ric}.num_rejected = num_active_rejected + num_inactive_rejected;
	mrej{ric}.num_active_rejected = num_active_rejected;
	mrej{ric}.active_rejected = int8(active_rejected); % Array with 1's indicating rejected "task" scans
	mrej{ric}.num_inactive_rejected = num_inactive_rejected;
	mrej{ric}.inactive_rejected = int8(inactive_rejected); % Array with 1's indicating rejected "rest" scans
 end % for rin
end %if max(rejected) > 0,

try, mrej; catch mrej = 0; end % Set a return value of 0 if we didn't do anything.
